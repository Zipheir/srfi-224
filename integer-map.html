<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
   <style>pre.example { margin-left: 2em; }</style>
  <title>Integer Mappings</title>
</head>
<body>
<h1>Integer Mappings</h1>

<h1>Author</h1>

<p>Wolfgang Corcoran-Mathe</p>

<h1>Abstract</h1>

<p>Integer maps, or <em>imappings</em>, are finite sets, where each element is
an association between an exact-integer key and an arbitrary Scheme
object.  They are similar to the general mappings of SRFI 146, but the
restricted key-type allows implementations of imappings to benefit from
optimized structures and algorithms.  This library provides a rich set
of operations on imappings, including analogues of most of the forms
provided by SRFI 146.  Imappings have no intrinsic order, but may be
treated as ordered sets, using the natural ordering on keys; a
substantial sublibrary for working with imappings in this fashion is
included.</p>

<h1>Rationale</h1>

<h1>Specification</h1>

<p>Imappings form a new type, as if created by <code>define-record-type</code>
(see R7RS § 5.5). The effects of using record-type inspection or inheritance
for the imapping type are unspecified.</p>

<p>It is an error to add or remove an association of an imapping while
iterating over it.</p>

<h2>Dependencies</h2>

<p>The specification of this SRFI depends on the Maybe and Either types
specified in <a href="https://srfi.schemers.org/srfi-189">SRFI 189</a>,
and on the comparator type described in
<a href="https://srfi.schemers.org/srfi-128">SRFI 128</a>.  The sample
implementation has further dependencies; see the
<a href="#implementation">appropriate section</a> for more details.</p>

<h2>Notation</h2>

<p>The naming conventions of this document are consistent with those used
in the R7RS Scheme standard.</p>

<p>The following names are used for the parameters of procedures:</p>

<table>
<tr><td><em>obj</em></td><td>Any Scheme object.</td></tr>
<tr><td><em>boolean</em></td><td>A boolean.</td></tr>
<tr><td><em>imap</em></td><td>An integer map (imapping).</td></tr>
<tr><td><em>k</em></td><td>An exact integer.</td></tr>
<tr><td><em>list</em></td><td>A proper list.</td></tr>
<tr><td><em>alist</em></td><td>An association list.</td></tr>
<tr><td><em>proc</em></td><td>A procedure.</td></tr>
<tr><td><em>mproc</em></td><td>A procedure returning a Maybe object.</td></tr>
<tr><td><em>pred</em></td><td>A predicate.</td></tr>
<tr><td><em>comp</em></td><td>A [SRFI 128](https://srfi.schemers.org/srfi-128/srfi-128.html) comparator object.</td></tr>
</table>


<p>It is an error (unless otherwise noted) if the procedures are passed arguments
that do not have the type implied by the argument names.</p>

<p>Each procedure is written in the form</p>

<p><code>(</code><em>proc arg₁ arg₂</em> …<code>)</code> → <em>type</em>₁ <em>type</em>₂ …</p>

<p>where <em>proc</em> is the name of the procedure, the <em>args</em> are its
parameters, and the <em>types</em> are the types of the objects it returns.
The latter refer (informally) to Scheme types, e.g. boolean, integer,
etc.  An exception is the notation &lsquo;*&rsquo;, which indicates that the type
of the value depends on the context of the procedure call.
For example, Scheme&rsquo;s <code>list-ref</code> procedure would be written</p>

<p><code>(</code>list-ref <em>list k</em><code>) → *</code></p>

<p>since the type of the return value depends on <em>list</em>.</p>

<h3>Linear update</h3>

<p>The procedures of this SRFI, by default, are "pure functional"--they
do not alter their parameters.  However, this SRFI also defines
"linear-update" procedures, all of whose names end in <code>!</code>.
They have hybrid pure/side-effecting semantics: they are allowed,
but not required, to side-effect one of their parameters in
order to construct their result.  An implementation may legally
implement these procedures as pure, side-effect-free functions, or it
may implement them using side effects, depending upon the details of
what is the most efficient or simple to implement in terms of the
underlying representation.</p>

<p>It is an error to rely upon these procedures working by side
effect.  For example, this is not guaranteed to work:</p>

<pre class="example">(let* ((imap1 (imapping 1 'b 2 'c))
       (imap2 (imapping-adjoin! imap1 3 'd)))
  imap1) ; Could be either {(1, b), (2, c)} or {(1, b), (2, c) (3, d)}.
</pre>

<p>However, this is well-defined:</p>

<pre class="example">(let ((imap1 (imapping 1 'b 2 'c)))
  (imapping-adjoin! imap1 3 'd))
</pre>

<p>So clients of these procedures write in a functional style, but
must additionally be sure that, when the procedure is called, there
are no other live references to the potentially-modified imapping
(hence the term "linear update").</p>

<p>There are two benefits to this convention:</p>

<ul><li><p>Implementations are free to provide the most efficient
possible implementation, either functional or side-effecting.</p></li>

<li><p>Programmers may nonetheless continue to assume that imappings are
purely functional data structures: they may be reliably shared without
needing to be copied, uniquified, and so forth.</p></li></ul>

<p>In practice, these procedures are most useful for efficiently
constructing isets in a side-effecting manner, in some limited local
context, before passing the iset outside the local construction scope
to be used in a functional manner.</p>

<p>Scheme provides no assistance in checking the linearity of the
potentially side-effected parameters passed to these functions--there's
no linear type checker or run-time mechanism for detecting
violations.</p>

<p>Note that if an implementation uses no side effects at all, it is
allowed to return existing imappings rather than newly allocated ones,
even where this SRFI explicitly says otherwise.</p>

<h2>Index</h2>

<ul>
<li><p><a href="#constructors">Constructors</a>: <code>imapping, imapping-unfold, imapping-unfold-maybe, alist-&gt;imapping,
iset-&gt;imapping</code></p></li>
<li><p><a href="#predicates">Predicates</a>: <code>imapping?, imapping-contains?, imapping-empty?, imapping-disjoint?</code></p></li>
<li><p><a href="#accessors">Accessors</a>: <code>imapping-lookup, imapping-ref, imapping-ref/default, imapping-min, imapping-max</code></p></li>
<li><p><a href="#updaters">Updaters</a>: <code>imapping-adjoin, imapping-adjoin/combinator,
imapping-adjoin!, imapping-adjoin/combinator!, imapping-adjust, imapping-adjust/key,
imapping-adjust!, imapping-adjust/key!,
imapping-delete, imapping-delete!,
imapping-delete-all, imapping-delete-all!, imapping-alter, imapping-alter!, imapping-update,
imapping-update/key, imapping-update!, imapping-update/key!,
imapping-delete-min, imapping-delete-max, imapping-delete-min!, imapping-delete-max!,
imapping-update-min, imapping-update-max, imapping-update-min/key, imapping-update-max/key,
imapping-update-min!, imapping-update-max!, imapping-update-min/key!, imapping-update-max/key!,
imapping-pop-min, imapping-pop-max,
imapping-pop-min!, imapping-pop-max!</code></p></li>
<li><p><a href="#whole">The whole imapping</a>: <code>imapping-size,
imapping-count, imapping-count/key, imapping-any?, imapping-every?</code></p></li>
<li><p><a href="#traversal">Traversal</a>: <code>imapping-fold,
imapping-fold-right, imapping-fold/key, imapping-fold-right/key, imapping-map,
imapping-map/key, imapping-map!, imapping-map/key!,
imapping-map-&gt;list, imapping-map/key-&gt;list, imapping-for-each,
imapping-for-each/key, imapping-filter-map, imapping-filter-map/key,
imapping-filter-map!, imapping-filter-map/key!,
imapping-map-either, imapping-map-either/key,
imapping-map-either!, imapping-map-either/key!,
imapping-relation-map</code></p></li>
<li><p><a href="#filter">Filter</a>: <code>imapping-filter, imapping-filter/key,
imapping-filter!, imapping-filter/key!,
imapping-remove, imapping-remove/key,
imapping-remove!, imapping-remove/key!,
imapping-partition, imapping-partition/key,
imapping-partition!, imapping-partition/key!</code></p></li>
<li><p><a href="#conversion">Copying and conversion</a>: <code>imapping-copy, imapping-&gt;alist,
imapping-&gt;decreasing-alist, imapping-keys,
imapping-values, imapping-keys-set</code></p></li>
<li><p><a href="#comparison">Comparison</a>: <code>imapping=?, imapping&lt;?, imapping&gt;?, imapping&lt;=?, imapping&gt;=?</code></p></li>
<li><p><a href="#settheory">Set theory operations</a>: <code>imapping-union, imapping-intersection, imapping-difference,
imapping-xor,
imapping-union!, imapping-intersection!, imapping-difference!, imapping-xor!,
imapping-union/combinator, imapping-intersection/combinator,
imapping-union/combinator!, imapping-intersection/combinator!</code></p></li>
<li><p><a href="#submappings">Submappings</a>: <code>imapping-open-interval, imapping-closed-interval,
imapping-open-closed-interval, imapping-closed-open-interval,
imapping-open-interval!, imapping-closed-interval!,
imapping-open-closed-interval!, imapping-closed-open-interval!,
isubmapping=, isubmapping&lt;, isubmapping&lt;=, isubmapping&gt;=,
isubmapping&gt;,
isubmapping=!, isubmapping&lt;!, isubmapping&lt;=!, isubmapping&gt;=!,
isubmapping&gt;!</code></p></li>
</ul>

<h2 id="constructors">Constructors</h2>

<p><code>(imapping</code> <em>k</em>₁ <em>obj</em>₁ <em>k</em>₂ <code>…) → imapping</code></p>

<p>Returns a new imapping.  The arguments alternate between keys (which
must be exact integers) and values (which may be anything); the
resulting imapping contains these (<em>k</em>, <em>obj</em>) associations.
The number of arguments must be even.  If duplicate keys occur in
the arguments, earlier associations take priority.</p>

<p>Examples:</p>
<pre class="example"><code>(imapping-&gt;alist (imapping 0 'a 1 'b 2 'c)) ⇒ ((0 . a) (1 . b) (2 . c))
(imapping-&gt;alist (imapping -10 "worf" -10 "yar")) ⇒ ((-10 . "worf"))
</code></pre>

<p><code>(imapping-unfold</code> <em>stop? mapper successor seed</em><code>) → imapping</code></p>

The arguments have the following types:
<ul>
<li><em>stop?</em> : <code>* → boolean</code></li>
<li><em>mapper</em> : <code>* → exact-integer *</code></li>
<li><em>successor</em> : <code>* → *</code></li>
<li><em>seed</em> : <code>*</code></li>
</ul>

<p>Unfold a new imapping from the initial seed value <em>seed</em>.
<em>mapper</em> is applied to each seed and returns two values, a key
and an associated value, which are adjoined to the new imapping.
<em>successor</em> maps each seed to a new seed.
Unfolding terminates when the predicate <em>stop?</em> returns a true
value when applied to the current seed.</p>

<p>Example:</p>
<pre class="example"><code>(imapping-&gt;alist
 (imapping-unfold (lambda (i) (= i 4))
                  (lambda (i) (values i (make-string i #\a)))
                  (lambda (i) (+ i 1))
                  0))
 ⇒ ((0 . "") (1 . "a") (2 . "aa") (3 . "aaa"))
</code></pre>

<p><code>(imapping-unfold-maybe</code> <em>mproc seed</em><code>) → imapping</code></p>

The arguments have the following types:
<ul>
<li><em>mproc</em> : <code>* → maybe[exact-integer, *, *]</code></li>
<li><em>seed</em> : <code>*</code></li>
</ul>

<p>Unfold a new imapping.  <em>mproc</em> is applied to <em>seed</em> and returns
a Maybe value.  If this value is Nothing, then unfolding terminates.
If it is Just <em>k v seed′</em>, then a new association
<em>(k, v)</em> is added to the resulting imapping and unfolding continues
with <em>seed′</em>.</p>

<p>Example:</p>
<pre class="example"><code>(imapping-&gt;alist
 (imapping-unfold-maybe (lambda (i)
                          (if (&lt; i -3)
                              (nothing)
                              (just i (square i) (- i 1))))
                        -1))
 ⇒ ((-3 . 9) (-2 . 4) (-1 . 1))
</code></pre>

<strong>Rationale:</strong> As well as sometimes leading to more compact
expressions than the
traditional "three procedure" unfold, <code>imapping-unfold-maybe</code>
is also more efficient when the programmer wants the value of each new seed
to depend on the computed key and value.  For example,
assume that we apply some procedure <em>f</em> to a seed <em>s</em> to get a
key <em>k</em> and a value <em>v</em>, and that we also want to compute a new
seed from <em>k</em> and <em>v</em>.  Using <em>imapping-unfold</em>, we'd
have no choice other than to compute <em>k</em> and <em>v</em> twice:

<pre class="example"><code>(imapping-unfold stop?
                 f
                 (lambda (s)
                   (let-values (((k v) (f s)))
                     (let ((s* …))
                       s*)))
                 seed)</code></pre>

Using <code>imapping-unfold-maybe</code>, however, it's easy to write an
equivalent unfold which computes <em>k</em> and <em>v</em> only once for
each step:

<pre class="example"><code>(imapping-unfold-maybe (lambda (s)
                         (if (stop? s)
                             (nothing)
                             (let-values (((k v) (f s)))
                               (let ((s* …))
                                 (just k v s*)))))
                       seed)</code></pre>

This may be preferable when <em>f</em> is expensive to apply.

<p><code>(alist-&gt;imapping</code> <em>alist</em><code>) → imapping</code></p>

<p>Returns a new imapping containing the associations of <em>alist</em>.
It is an error if the car of any pair in <em>alist</em> is not an
exact integer.</p>

<p>Example:</p>
<pre class="example"><code>(imapping-&gt;alist (alist-&gt;imapping '((1 . b) (0 . a) (2 . c))))
 ⇒ '((0 . a) (1 . b) (2 . c))
</code></pre>

<p><code>(iset-&gt;imapping</code> <em>proc iset</em><code>) → imapping</code></p>

<p><em>proc</em> is of type <code>exact-integer → *</code>.</p>

<p>Returns a new imapping constructed from the elements of the integer
set <em>iset</em> (see
<a href="https://srfi.schemers.org/srfi-217/srfi-217.html">SRFI 217</a>).
For each integer <em>k</em> in <em>iset</em>, the association
(<em>k</em>, (<em>proc</em> <em>k</em>)) is added to the imapping.
<em>iset</em> is traversed in an unspecified order.</p>

<p>Example:</p>
<pre class="example"><code>(imapping-&gt;alist (iset-&gt;imapping square (iset 2 4 6 8)))
 ⇒ ((2 . 4) (4 . 16) (6 . 36) (8 . 64))
</code></pre>

<h2 id="predicates">Predicates</h2>

<p><code>(imapping?</code> <em>obj</em><code>) → boolean</code></p>

<p>Returns <code>#t</code> if and only if <em>obj</em> is an imapping.</p>

<p><code>(imapping-contains? imap k) → boolean</code></p>

<p>Returns <code>#t</code> if and only if <em>imap</em> contains an association for key <em>k</em>.</p>
<p>Examples:</p>
<pre class="example"><code>(imapping-contains? (imapping 1 'b) 1) ⇒ #t
(imapping-contains? (imapping 1 'b) 0) ⇒ #f
</code></pre>

<p><code>(imapping-empty?</code> <em>imap</em><code>) → boolean</code></p>

<p>Returns <code>#t</code> if and only if <em>imap</em> contains no associations.</p>
<p>Examples:</p>
<pre class="example"><code>(imapping-empty? (alist-&gt;imapping '())) ⇒ #t
(imapping-empty? (alist-&gt;imapping '((0 . a)))) ⇒ #f
</code></pre>

<p><code>(imapping-disjoint?</code> <em>imap</em>₁ <em>imap</em>₂<code>) → boolean</code></p>

<p>Returns <code>#t</code> if and only if <em>imap</em>₁ and <em>imap</em>₂ have no keys in common.</p>
<p>Examples:</p>
<pre class="example"><code>(imapping-disjoint? (imapping 0 'a) (imapping 1 'b)) ⇒ #t
(imapping-disjoint? (imapping 1 '(b)) (imapping 1 'b)) ⇒ #f
</code></pre>

<h2 id="accessors">Accessors</h2>

<p><code>(imapping-lookup</code> <em>imap k</em><code>) → maybe[*]</code></p>

<p>If an association <em>(k, v)</em> occurs in <em>imap</em>, returns Just <em>v</em>.
Otherwise, returns Nothing.</p>
<p>Examples:</p>
<pre class="example"><code>(imapping-lookup (imapping 36864 'zap) 36864) ⇒ just['zap]
(imapping-lookup (imapping 0 'a) 36864) ⇒ nothing
</code></pre>

<p><code>(imapping-ref</code> <em>imap k</em><code>) → *</code></p>

<p>If an association <em>(k, v)</em> occurs in <em>imap</em>, returns <em>v</em>.
Otherwise, an error is signaled.</p>

<p>Examples:</p>

<pre class="example"><code>(imapping-ref (imapping 36864 'zap) 36864) ⇒ zap
(imapping-ref (imapping 0 'a) 36864) ⇒ ; error
</code></pre>

<p><code>(imapping-ref/default</code> <em>imap k obj</em><code>) → *</code></p>

<p>If an association <em>(k, v)</em> occurs in <em>imap</em>, returns <em>v</em>.
Otherwise, returns <em>obj</em>.</p>

<p>Examples:</p>

<pre class="example"><code>(imapping-ref/default (imapping 36864 'zap) 36864 #f) ⇒ zap
(imapping-ref/default (imapping 0 'a) 36864 #f) ⇒ #f
</code></pre>

<p><code>(imapping-min</code> <em>imap</em><code>) → maybe[exact-integer, *]</code></p>

<p>Returns Just <em>k</em> <em>v</em>, where <em>k</em> is the least key of <em>imap</em>.
If <em>imap</em> is empty in the sense of <code>imapping-empty?</code>, returns
Nothing.</p>

<p>Examples:</p>

<pre class="example"><code>(imapping-min (imapping 0 'a 1 'b 2 'c)) ⇒ just[0, 'a]
(imapping-min (imapping)) ⇒ nothing
</code></pre>

<p><code>(imapping-max</code> <em>imap</em><code>) → maybe[exact-integer, *]</code></p>

<p>Returns Just <em>k</em> <em>v</em>, where <em>k</em> is the greatest key of <em>imap</em>.
If <em>imap</em> is empty in the sense of <code>imapping-empty?</code>, returns
Nothing.</p>

<p>Examples:</p>

<pre class="example"><code>(imapping-max (imapping 0 'a 1 'b 2 'c)) ⇒ just[2, 'c]
(imapping-max (imapping)) ⇒ nothing
</code></pre>

<h2 id="updaters">Updaters</h2>

<p><code>(imapping-adjoin</code> <em>imap k</em>₁ <em>obj</em>₁ <em>k</em>₂ <code>…) → imapping</code></p>

<p>Returns a new imapping containing all of the associations of
<em>imap</em> as well as the associations (<em>k</em>₁, <em>v</em>₁), (<em>k</em>₂, <em>k</em>₂), …
The number of key/value arguments must be even.</p>

<p>If any of the keys already have associations in <em>imap</em>, the old
associations are replaced.</p>

<p>Examples:</p>

<pre class="example"><code>(imapping-&gt;alist (imapping-adjoin (imapping 1 'b) 0 'a)) ⇒ ((0 . a) (1 . b))
</code></pre>

<p><code>(imapping-adjoin!</code> <em>imap k</em>₁ <em>obj</em>₁ <em>k</em>₂ <code>…) → imapping</code></p>

<p><code>imapping-adjoin!</code> is the same as <code>imapping-adjoin</code>,
except that it is permitted to mutate and return the <em>imap</em> argument rather
than allocating a new imapping.</p>

<p><code>(imapping-adjoin/combinator</code> <em>imap proc k</em>₁ <em>obj</em>₁ <em>k</em>₂ …)`</p>

<p>Similar to <code>imapping-adjoin</code>, except that duplicate associations
are combined with <em>proc</em>, which is a procedure of type <code>* * → *</code>.
<em>proc</em> is called on the new and old values (in that order) associated
with a duplicated key and is expected to return a value for the key.</p>

<p>Example:</p>

<pre class="example"><code>(imapping-&gt;alist
 (imapping-adjoin/combinator (imapping 0 "geordi" 1 "reginald")
                             (lambda (last first)
                               (string-append first " " last))
                             0 "laforge"
                             1 "barclay"))
 ⇒ ((0 . "geordi laforge") (1 . "reginald barclay"))
</code></pre>

<p><code>(imapping-adjoin/combinator!</code> <em>imap proc k</em>₁ <em>obj</em>₁ <em>k</em>₂ <code>…)</code></p>

<p><code>imapping-adjoin/combinator!</code> is the same as
<code>imapping-adjoin/combinator</code>, except that it is permitted
to mutate and return the <em>imap</em> argument rather
than allocating a new imapping.</p>

<p><code>(imapping-adjust imap k proc) → imapping</code><br>
<code>(imapping-adjust/key imap k proc) → imapping</code></p>

<p>The <em>proc</em> parameter of <code>imapping-adjust</code> is a
procedure of type <code>* → *</code>; that of
<code>imapping-adjust/key</code> is of type
<code>exact-integer * → *</code>.</p>

<p>Returns a new imapping in which the association (<em>k</em>, <em>v</em>) in <em>imap</em>
is replaced by (<em>k</em>, (<em>proc v</em>)), or by (<em>k</em>, (<em>proc k v</em>)) in the
case of <code>imapping-adjust/key</code>.  If <em>k</em> has no association in <em>imap</em>,
then a copy of <em>imap</em> is returned.</p>

<p>Examples:</p>

<pre class="example"><code>(imapping-&gt;alist (imapping-adjust (imapping 0 -200 1 -100) 0 abs))
 ⇒ '((0 . 200) (1 -100))

(imapping-&gt;alist
 (imapping-adjust/key (imapping 64 "var")
                      64
                      (lambda (k s) (string-append s (number-&gt;string k)))))
 ⇒ ((64 . "var64"))
</code></pre>

<p><code>(imapping-adjust! imap k proc) → imapping</code><br>
<code>(imapping-adjust/key! imap k proc) → imapping</code></p>

<p><code>imapping-adjust!</code> and <code>imapping-adjust/key!</code>
are the same as <code>imapping-adjust</code> and
<code>imapping-adjust/key</code>, respectively, except that they are
permitted to mutate and return the <em>imap</em> argument rather
than allocating a new imapping.</p>

<p><code>(imapping-delete imap</code> <em>k</em>₁ <em>k</em>₂ <code>…) → imapping</code></p>

<p>Returns a new imapping with the same associations as <em>imap</em>, except
those for keys equal to <em>k</em>₁, <em>k</em>₂, ….  If a key does not have an
association in <em>imap</em>, it is ignored.</p>

<p>Example:</p>

<pre class="example"><code>(imapping-&gt;alist (imapping-delete (imapping 0 -200 1 -100) 0)) ⇒ ((1 . -100))
</code></pre>

<p><code>(imapping-delete! imap</code> <em>k</em>₁ <em>k</em>₂ <code>…) → imapping</code></p>

<p><code>imapping-delete!</code> is the same as
<code>imapping-delete</code>, except that it is permitted
to mutate and return the <em>imap</em> argument rather
than allocating a new imapping.</p>

<p><code>(imapping-delete-all</code> <em>imap list</em><code>) → imapping</code></p>

<p>Returns a new imapping with the same associations as <em>imap</em>, except
those for keys equal to an element of <em>list</em>.</p>

<p>Example:</p>

<pre class="example"><code>(imapping-&gt;alist (imapping-delete-all (imapping 0 'a 1 'b 2 'c) '(1 2)))
 ⇒ ((0 . a))
</code></pre>

<p><code>(imapping-delete-all!</code> <em>imap list</em><code>) → imapping</code></p>

<p><code>imapping-delete-all!</code> is the same as
<code>imapping-delete-all</code>, except that it is permitted
to mutate and return the <em>imap</em> argument rather
than allocating a new imapping.</p>

<p><code>(imapping-update</code> <em>imap k mproc</em><code>) → imapping</code><br>
<code>(imapping-update/key</code> <em>imap k mproc</em><code>) → imapping</code></p>

<p>Returns a new imapping with the same associations as <em>imap</em>, except
that the association for <em>k</em> is updated as follows.  <em>mproc</em> is
applied to the value associated with <em>k</em>.
If it returns Nothing, the association is deleted;
if it returns Just <em>v</em>, then <em>(k, v)</em> is added to the new imapping.</p>

<p><code>imapping-update/key</code> is the same as <code>imapping-update</code>, except that
<em>mproc</em> is called on <em>n</em> and its associated value, in that order.</p>

<p>Simple versions of several other update operations may be defined
in terms of <code>imapping-update</code>, e.g.:</p>

<pre><code>  (imapping-delete imap k)
≡
  (imapping-update imap k (lambda (_) (nothing)))

  (imapping-adjoin imap k v)
≡
  (imapping-update imap k (lambda (_) (just v)))
</code></pre>
<p>Examples:</p>

<pre class="example"><code>;; Delete the association for 1 if its value is a symbol.
(imapping-&gt;alist
 (imapping-update (imapping 0 'a 1 'b 2 'c)
                  1
                  (lambda (v)
                    (if (symbol? v)
                        (nothing)
                        (just v)))))
 ⇒ ((0 . a) (2 . c))

;; Replace the value associated with 1.
(imapping-&gt;alist
 (imapping-update/key (imapping 0 'a 1 'b 2 'c) 1 (lambda (k _v) (just k))))
 ⇒ ((0 . a) (1 . 1) (2 . c))
</code></pre>

<p><code>(imapping-update!</code> <em>imap k mproc</em><code>) → imapping</code><br>
<code>(imapping-update/key!</code> <em>imap k mproc</em><code>) → imapping</code></p>

<p><code>imapping-update!</code> and <code>imapping-update/key!</code>
are the same as <code>imapping-update</code> and
<code>imapping-update/key</code>, respectively, except that they are
permitted to mutate and return the <em>imap</em> argument rather
than allocating a new imapping.</p>

<p><code>(imapping-alter</code> <em>imap k proc</em><code>) → imapping</code></p>

<p><em>proc</em> is a procedure of type <code>maybe[*] → maybe[*]</code>.</p>

<p>Returns a new imapping with the same associations as <em>imap</em>, except
that the association, or lack thereof, for <em>k</em> is updated as follows.
If the association <em>(k, v)</em> exists in <em>imap</em>, then <em>proc</em> is called on
Just <em>v</em>; if no such association exists, then <em>proc</em> is called on
Nothing.  If the result of this application is Nothing, the
association is deleted (or no new association is added); if the result
is Just <em>v′</em>, a new association <em>(k, v′)</em> is added to the new
imapping, replacing any old association for <em>k</em>.</p>

<p><code>imapping-alter</code> is a very general operator on imappings, and most
of the other update operations may be defined in terms of it.  For
example:</p>

<pre><code>  (imapping-update imap k f)
≡
  (imapping-alter imap k (lambda (m)
                           (maybe-ref m
                                      nothing
                                      (lambda (v) (f v)))))
</code></pre>

<p>Examples:</p>

<pre class="example"><code>;; Insert an association for 4 if it's not present.
(imapping-&gt;alist
 (imapping-alter (imapping 0 'a 1 'b)
                 4
                 (lambda (m)
                   (if (nothing? m) (just 'e) m))))
 ⇒ ((0 . a) (1 . b) (4 . e))

;; Delete an association for 1 if its value is a symbol.
(imapping-&gt;alist
 (imapping-alter (imapping 0 'a 1 'b)
                 1
                 (lambda (m)
                   (maybe-bind m (lambda (v)
                                   (if (symbol? v)
                                       (nothing)
                                       (just v)))))))
 ⇒ ((0 . a))
</code></pre>

<p><code>(imapping-alter!</code> <em>imap k proc</em><code>) → imapping</code></p>

<p><code>imapping-alter!</code> is the same as
<code>imapping-alter</code>, except that it is permitted
to mutate and return the <em>imap</em> argument rather
than allocating a new imapping.</p>

<p><code>(imapping-delete-min</code> <em>imap</em><code>) → imapping</code><br>
<code>(imapping-delete-max</code> <em>imap</em><code>) → imapping</code></p>

<p>Returns a new imapping with the same associations as <em>imap</em>, except
for the association with the least/greatest key.  If <em>imap</em> is empty,
an error is signalled.</p>

<p><code>(imapping-delete-min!</code> <em>imap</em><code>) → imapping</code><br>
<code>(imapping-delete-max!</code> <em>imap</em><code>) → imapping</code></p>

<p><code>imapping-delete-min!</code> and <code>imapping-delete-max!</code>
are the same as <code>imapping-delete-min</code> and
<code>imapping-delete-max</code>, respectively, except that they are
permitted to mutate and return the <em>imap</em> argument rather
than allocating a new imapping.</p>

<p>Examples:</p>

<pre class="example"><code>(imapping-delete-min (imapping 0 'a 1 'b 2 'c)) ⇒ ((1 . b) (2 . c))
(imapping-delete-max (imapping 0 'a 1 'b 2 'c)) ⇒ ((0 . a) (1 . b))
</code></pre>

<p><code>(imapping-update-min</code> <em>imap mproc</em><code>) → imapping</code><br>
<code>(imapping-update-max</code> <em>imap mproc</em><code>) → imapping</code><br>
<code>(imapping-update-min/key</code> <em>imap mproc</em><code>) → imapping</code><br>
<code>(imapping-update-max/key</code> <em>imap mproc</em><code>) → imapping</code></p>

<p>The <em>mproc</em> argument of <code>imapping-update-min</code> and <code>-max</code> is of
type <code>* → maybe[*]</code>; that of <code>imapping-update-min/key</code> and of
<code>-max/key</code> is of type <code>exact-integer * → maybe[*]</code>.</p>

<p>Returns a new imapping with the same associations as <em>imap</em>, except
that the association for the least/greatest key <em>k</em> is updated as
follows.  <em>mproc</em> is applied to the value associated with <em>k</em> and is
expected to return a Maybe value.  If it returns Nothing, the
association is deleted; if it returns Just <em>v</em>, then <em>(k, v)</em> is added
to the new imapping.  If <em>imap</em> is empty, an error is signalled.</p>

<p><code>imapping-update-min/key</code> and <code>imapping-update-max/key</code> are the same
as <code>imapping-update-min</code> and <code>imapping-update-max</code>, respectively,
except that <em>mproc</em> is called on <em>k</em> and its associated value, in that
order.</p>

<p>Examples:</p>

<pre class="example"><code>(imapping-&gt;alist
 (imapping-update-min (imapping -5 "phaser" -1 "tricorder")
                      (lambda (v)
                        (if (symbol? v)
                            (just v)
                            (nothing)))))
 ⇒ ((-1 . "tricorder"))

(imapping-&gt;alist
 (imapping-update-max/key (imapping -5 "phaser" -1 "tricorder")
                          (lambda (k v)
                            (if (and (negative? k) (string? v))
                                (just (string-length v))
                                (nothing)))))
 ⇒ ((-5 . "phaser") (-1 . 9))
</code></pre>

<p><code>(imapping-update-min!</code> <em>imap mproc</em><code>) → imapping</code><br>
<code>(imapping-update-max!</code> <em>imap mproc</em><code>) → imapping</code><br>
<code>(imapping-update-min/key!</code> <em>imap mproc</em><code>) → imapping</code><br>
<code>(imapping-update-max/key!</code> <em>imap mproc</em><code>) → imapping</code></p>

<p>These are linear-update variants of
<code>imapping-update-min</code>, etc..  They are permitted to
mutate and return the <em>imap</em> argument rather than allocating
a new imapping.</p>

<p><code>(imapping-pop-min</code> <em>imap</em><code>) → maybe[exact-integer, *, imapping]</code><br>
<code>(imapping-pop-max</code> <em>imap</em><code>) → maybe[exact-integer, *, imapping]</code></p>

<p>Returns Just <em>k v imap′</em>, where (<em>k</em>, <em>v</em>) is the association of
<em>imap</em> with the least/greatest key and <em>imap′</em> is a newly-allocated
imapping containing all of the associations of <em>imap</em> except for
(<em>k</em>, <em>v</em>).  If <em>imap</em> is empty, returns Nothing.</p>

<p>Example:</p>

<pre class="example"><code>(maybe-let*-values (((k v imap)
                     (imapping-pop-min (imapping 0 'a 1 'b 2 'c))))
  (values k v (imapping-&gt;alist imap)))
 ⇒ (just 0 a ((1 . b) (2 . c)))
</code></pre>

<p><code>(imapping-pop-min!</code> <em>imap</em><code>) → maybe[exact-integer, *, imapping]</code><br>
<code>(imapping-pop-max!</code> <em>imap</em><code>) → maybe[exact-integer, *, imapping]</code></p>

<p><code>imapping-pop-min!</code> and <code>imapping-pop-max!</code>
are the same as <code>imapping-pop-min</code> and
<code>imapping-pop-max</code>, respectively, except that they are
permitted to mutate and return the <em>imap</em> argument rather
than allocating a new imapping.</p>

<h2 id="whole">The whole imapping</h2>

<p><code>(imapping-size</code> <em>imap</em><code>) → exact-integer</code></p>

<p>Returns the number of associations in <em>imap</em>.</p>

<p><code>(imapping-count</code> <em>pred imap</em><code>) → exact-integer</code><br>
<code>(imapping-count/key</code> <em>pred imap</em><code>) → exact-integer</code></p>

<p>Returns the number of associations in <em>imap</em> whose values satisfy
<em>pred</em>.</p>

<p><code>imapping-count/key</code> is the same, except that <em>pred</em> is called on
the key and value of each association.</p>

<p>Examples:</p>

<pre class="example"><code>(imapping-count even? (imapping 0 1 1 2 2 4 3 8)) ⇒ 3
(imapping-count/key (lambda (k s) (= k (string-length s)))
                    (imapping 0 "x" 1 "y" 2 "z"))
 ⇒ 1
</code></pre>

<p><code>(imapping-any?</code> <em>pred imap</em><code>) → boolean</code></p>

<p>Returns <code>#t</code> if and only if there exists an association in <em>imap</em> whose value
satisfies <em>pred</em>.  <em>imap</em> is traversed in ascending numerical order
of keys.</p>

<p>Example:</p>

<pre class="example"><code>(imapping-any? odd? (imapping 0 1 1 2 2 4 3 8)) ⇒ #t
</code></pre>

<p><code>(imapping-every?</code> <em>pred imap</em><code>) → boolean</code></p>

<p>Returns <code>#t</code> if and only if the value of every association in <em>imap</em> satisfies
<em>pred</em>, or if <em>imap</em> is empty.  <em>imap</em> is traversed in ascending
numerical order of keys.</p>

<p>Example:</p>

<pre class="example"><code>(imapping-every? integer? (imapping 0 1 1 2 2 4 3 8)) ⇒ #t
</code></pre>

<h2 id="traversal">Traversal</h2>

<p><code>(imapping-map</code> <em>proc imap</em><code>) → imapping</code><br>
<code>(imapping-map/key</code> <em>proc imap</em><code>) → imapping</code></p>

<p>The <em>proc</em> argument of <code>imapping-map</code> is of type <code>* → *</code>;
that of <code>imapping-map/key</code> is of type <code>exact-integer * → *</code>.</p>

<p>Returns a new imapping.  For each association <em>(n, v)</em> in <em>imap</em>,
the association <em>(n, (proc v))</em> is added to the new imapping.
Associations are traversed in an arbitrary order.  The dynamic order
of the applications of <em>proc</em> to the elements of <em>imap</em> is
unspecified.</p>

<p><code>imapping-map/key</code> is the same, except that <em>proc</em> is called on
the key and value of each association.</p>

<p>Examples:</p>

<pre class="example"><code>(imapping-&gt;alist
 (imapping-map string-length
               (imapping 0 "picard" 1 "riker" 2 "troi")))
 ⇒ ((0 . 6) (2 . 5) (3 . 4))

(imapping-&gt;alist
 (imapping-map/key (lambda (k s)
                     (string-append s (number-&gt;string k)))
                   (imapping 256 "x" 512 "y" 1024 "z")))
 ⇒ ((256 . "x256") (512 . "y512") (1024 . "z1024"))
</code></pre>

<p>Note that, in contrast to SRFI 146&rsquo;s map procedures, these procedures
transform the values of <em>imap</em> only; that is, the set of keys of the
resulting imapping is the same as that of <em>imap</em>.</p>

<p><code>(imapping-map!</code> <em>proc imap</em><code>) → imapping</code><br>
<code>(imapping-map/key!</code> <em>proc imap</em><code>) → imapping</code></p>

<p><code>imapping-map!</code> and <code>imapping-map/key!</code>
are the same as <code>imapping-map</code> and
<code>imapping-map/key</code>, respectively, except that they are
permitted to mutate and return the <em>imap</em> argument rather
than allocating a new imapping.</p>

<p><code>(imapping-for-each</code> <em>proc imap</em><code>) → unspecified</code><br>
<code>(imapping-for-each/key</code> <em>proc imap</em><code>) → unspecified</code></p>

<p>Calls <em>proc</em> on the value of each association in <em>imap</em> and returns
an unspecified value.  <em>imap</em> in traversed in ascending numerical
order of keys.</p>

<p><code>imapping-for-each/key</code> is the same, except that <em>proc</em> is called on
the key and value of each association.</p>

<p>Example:</p>

<pre class="example"><code>(let ((sum 0))
  (imapping-for-each (lambda (v) (set! sum (+ sum v)))
                     (imapping 0 1 1 2 2 4 3 8))
  sum)
 ⇒ 15
</code></pre>

<p><code>(imapping-fold</code> <em>kons knil imap</em><code>) → *</code><br>
<code>(imapping-fold-right</code> <em>kons knil imap</em><code>) → *</code><br>
<code>(imapping-fold/key</code> <em>kons knil imap</em><code>) → *</code><br>
<code>(imapping-fold-right/key</code> <em>kons knil imap</em><code>) → *</code></p>

<p>The <em>kons</em> argument of <code>imapping-fold</code> and <code>imapping-fold-right</code> is a
procedure of type <code>* * → *</code>; that of <code>imapping-fold/key</code>
and of <code>imapping-fold-right/key</code> is of type <code>exact-integer * * → *</code>.
<em>knil</em> can be any object.</p>

<p>Folds <em>kons</em> over <em>imap</em>, using <em>knil</em> as the base value.  At
each step, <em>kons</em> is applied to the value of an association and to
the result of the last application.
<code>imapping-fold</code> folds in ascending numerical order of keys;
<code>imapping-fold-right</code> folds in descending order.</p>

<p><code>imapping-fold/key</code> and <code>imapping-fold-right/key</code> are the same
as <code>imapping-fold</code> and <code>imapping-fold-right</code>, respectively,
except that <em>kons</em> is also passed the key of each association as its first
argument.</p>

<p>Examples:</p>

<pre class="example"><code>(imapping-fold-right cons '() (imapping 0 "worf" 1 "data" 2 "crusher"))
 ⇒ ("worf" "data" "crusher")

(imapping-fold/key (lambda (k _ ks) (cons k ks))
                   '()
                   (imapping 0 "worf" 1 "data" 2 "crusher"))
 ⇒ (2 1 0)
</code></pre>

<p><code>(imapping-map-&gt;list</code> <em>proc imap</em><code>) → list</code><br>
<code>(imapping-map/key-&gt;list</code> <em>proc imap</em><code>) → list</code></p>

<p>Efficient fusion of <code>(imapping-values (imapping-map</code> <em>proc imap</em><code>))</code>.</p>

<p><code>imapping-map/key-&gt;list</code> is the same, except that <em>proc</em> is called on
the key and value of each association.</p>

<p>Example:</p>

<pre class="example"><code>(imapping-&gt;alist
 (imapping-map-&gt;list string-length
                     (imapping 0 "picard" 1 "riker" 2 "troi")))
 ⇒ (6 5 4)
</code></pre>

<p><code>(imapping-filter-map</code> <em>proc imap</em><code>) → imapping</code><br>
<code>(imapping-filter-map/key</code> <em>proc imap</em><code>) → imapping</code></p>

<p>The <em>proc</em> parameter of <code>imapping-filter-map</code> is a
procedure of type <code>* → *-or-#f</code>; that of
<code>imapping-filter-map/key</code> is of type
<code>exact-integer * → *-or-#f</code>.</p>

<p><code>imapping-filter-map</code> is similar to <code>imapping-map</code>,
but only associations for which <em>proc</em> returns a true value are
added to the new imapping.</p>

<p><code>imapping-filter-map/key</code> is the same, except that <em>proc</em>
is called on the key and value of each association.</p>

<p>Example:</p>

<pre class="example"><code>(imapping-&gt;alist
 (imapping-filter-map (lambda (v)
                        (and (positive? v) (square v)))
                      (imapping 0 2 1 -4 2 8)))
 ⇒ ((0 . 4) (2 . 64))
</code></pre>

<p><code>(imapping-filter-map!</code> <em>proc imap</em><code>) → imapping</code><br>
<code>(imapping-filter-map/key!</code> <em>proc imap</em><code>) → imapping</code></p>

<p><code>imapping-filter-map!</code> and <code>imapping-filter-map/key!</code>
are the same as <code>imapping-filter-map</code> and
<code>imapping-filter-map/key</code>, respectively, except that they are
permitted to mutate and return the <em>imap</em> argument rather
than allocating a new imapping.</p>

<p><code>(imapping-map-either</code> <em>proc imap</em><code>) → imapping imapping</code><br>
<code>(imapping-map-either/key</code> <em>proc imap</em><code>) → imapping imapping</code></p>

<p>The <em>proc</em> of <code>imapping-map-either</code> is a procedure
of type <code>* → either[*]</code>, where <code>either[*]</code> denotes
a SRFI 189 Either containing a single value.  The <em>proc</em> parameter
of <code>imapping-map-either/key</code> is of type
<code>exact-integer * → either[*]</code>.</p>

<p><code>imapping-map-either</code> maps <em>proc</em> over the values
of <em>imap</em> and returns imappings of the Left and of the Right
results.  For each association (<em>k</em>, <em>v</em>) in
<em>imap</em>, (<em>proc v</em>) is evaluated.  If the result is a
Left of a value <em>v</em>₁, then the association (<em>k</em>,
<em>v</em>₁) is added to the first new imapping.  If it is instead a
Right of <em>v</em>₂, then the association (<em>k</em>, <em>v</em>₂)
is added to the second new imapping.</p>

<p><code>imapping-map-either/key</code> is the same, except that <em>proc</em>
is called on the key and value of each association.</p>

<p>Example:</p>

<pre class="example"><code>(let-values (((lefts rights)
              (imapping-map-either
               (lambda (v)
                 (if (&gt;= v 0)
                     (right v)
                     (left v)))
               (imapping 0 -50 4 -25 8 25 12 50))))
  (values (imapping-&gt;alist lefts)
          (imapping-&gt;alist rights)))
 ⇒ ((0 . -50) (4 . -25))
   ((8 . 25) (12 . 50))
</code></pre>

<p><code>(imapping-map-either!</code> <em>proc imap</em><code>) → imapping imapping</code><br>
<code>(imapping-map-either/key!</code> <em>proc imap</em><code>) → imapping imapping</code></p>

<p><code>imapping-map-either!</code> and <code>imapping-map-either/key!</code>
are the same as <code>imapping-map-either</code> and
<code>imapping-map-either/key</code>, respectively, except that they are
permitted to mutate the <em>imap</em> to produce their results.</p>

<p><code>(imapping-relation-map</code> <em>proc imap</em><code>) → imapping</code></p>

<p><code>proc</code> must be a procedure of type
<code>exact-integer * → exact-integer *</code>.</p>

<p>Returns a new imapping whose associations are the results of
transforming both the keys and the values of <em>imap</em> with
<em>proc</em>.  For each association (<em>k</em>,
<em>v</em>) in <em>imap</em>, (<em>proc k v</em>) is evaluated to
return a new key and a new value which are associated in the new
imapping.  Duplicate keys are replaced, but the results in this case
are unpredictable; if <em>proc</em> is not injective, that is, if it
produces multiple associations with the same key, then it is unspecified
which one of these associations will be present in the resulting
imapping. The dynamic order of the applications of <em>proc</em> to the
elements of <em>imap</em> is unspecified.</p>

<p><strong>Rationale:</strong> <code>imapping-relation-map</code>
corresponds to <code>mapping-map</code> from SRFI 146 and is specified
primarily for compatibility with that SRFI.  It generalizes
<code>imapping-map</code> and <code>imapping-map/key</code>, and can
be used to produce a wide range of transformations on imappings.  This
generality comes at a price, however.  Certain familiar laws that hold
of <code>imapping-map</code> and other Scheme "map" functions do not
hold of <code>imapping-relation-map</code>; in particular, the size of
the input imapping <em>imap</em> may not be preserved, and a key with an
association in <em>imap</em> may not have an association in the
transformed imapping.</p>

<p>As such, <code>imapping-map</code> and <code>imapping-map/key</code>
likely conform better to the familiar pattern of Scheme "map" functions,
while being sufficiently general for most purposes.</p>

<h2 id="filter">Filter</h2>

<p><code>(imapping-filter</code> <em>pred imap</em><code>) → imapping</code><br>
<code>(imapping-filter/key</code> <em>pred imap</em><code>) → imapping</code></p>

<p>Returns a new imapping containing all of the associations of <em>imap</em>
whose values satisfy <em>pred</em>.</p>

<p><code>imapping-filter/key</code> is the same, except that <em>pred</em> is applied to
the key and value of each association.</p>

<p>Example:</p>

<pre class="example"><code>(imapping-&gt;alist (imapping-filter positive?
                                  (imapping 0 2 1 -4 2 8 3 -16)))
 ⇒ ((0 . 2) (2 . 8))
</code></pre>

<p><code>(imapping-filter!</code> <em>pred imap</em><code>) → imapping</code><br>
<code>(imapping-filter/key!</code> <em>pred imap</em><code>) → imapping</code></p>

<p><code>imapping-filter!</code> and <code>imapping-filter/key!</code>
are the same as <code>imapping-filter</code> and
<code>imapping-filter/key</code>, respectively, except that they are
permitted to mutate and return the <em>imap</em> argument rather
than allocating a new imapping.</p>

<p><code>(imapping-remove</code> <em>pred imap</em><code>) → imapping</code><br>
<code>(imapping-remove/key</code> <em>pred imap</em><code>) → imapping</code></p>

<p>Returns a new imapping containing all of the associations of <em>imap</em>
whose values do not satisfy <em>pred</em>.</p>

<p><code>imapping-remove/key</code> is the same, except that <em>pred</em> is applied to
the key and value of each association.</p>

<p>Example:</p>

<pre class="example"><code>(imapping-&gt;alist (imapping-remove positive?
                                  (imapping 0 2 1 -4 2 8 3 -16)))
 ⇒ ((1 . -4) (3 . -16))
</code></pre>

<p><code>(imapping-remove!</code> <em>pred imap</em><code>) → imapping</code><br>
<code>(imapping-remove/key!</code> <em>pred imap</em><code>) → imapping</code></p>

<p><code>imapping-remove!</code> and <code>imapping-remove/key!</code>
are the same as <code>imapping-remove</code> and
<code>imapping-remove/key</code>, respectively, except that they are
permitted to mutate and return the <em>imap</em> argument rather
than allocating a new imapping.</p>

<p><code>(imapping-partition</code> <em>pred imap</em><code>) → imapping imapping</code><br>
<code>(imapping-partition/key</code> <em>pred imap</em><code>) → imapping imapping</code></p>

<p>Returns two new imappings: the first contains all associations of
<em>imap</em> whose values satisfy <em>pred</em>, and the second contains those
whose values do not.</p>

<p><code>imapping-partition/key</code> is the same, except that <em>pred</em> is applied to
the key and value of each association.</p>

<p>Example:</p>

<pre class="example"><code>(let-values (((pos ~pos) (imapping-partition positive?
                                             (imapping 0 2 1 -4 2 8 3 -16))))
  (values (imapping-&gt;alist pos)
          (imapping-&gt;alist ~pos)))
 ⇒ ((0 . 2) (2 . 8))
   ((1 . -4) (3 . -16))
</code></pre>

<p><code>(imapping-partition!</code> <em>pred imap</em><code>) → imapping</code><br>
<code>(imapping-partition/key!</code> <em>pred imap</em><code>) → imapping</code></p>

<p><code>imapping-partition!</code> and <code>imapping-partition/key!</code>
are the same as <code>imapping-partition</code> and
<code>imapping-partition/key</code>, respectively, except that they are
permitted to mutate the <em>imap</em> argument to produce their results.</p>

<h2 id="conversion">Conversion</h2>

<p><code>(imapping-copy</code> <em>imap</em><code>) → imapping</code></p>

<p>Returns a newly allocated imapping containing the associations of
<code>imap</code>.</p>

<p><code>(imapping-&gt;alist</code> <em>imap</em><code>) → alist[exact-integer, *]</code></p>

<p>Returns a car/cdr alist containing the associations of <em>imap</em> in
ascending numerical order of keys.</p>

<p>Example:</p>

<pre class="example"><code>(imapping-&gt;alist (imapping 1 'a 2 'b)) ⇒ ((1 . a) (2 . b))
</code></pre>

<p><code>(imapping-&gt;decreasing-alist</code> <em>imap</em><code>) → alist[exact-integer, *]</code></p>

<p>Returns a car/cdr alist containing the associations of <em>imap</em> in
decreasing numerical order of keys.</p>

<p>Example:</p>

<pre class="example"><code>(imapping-&gt;alist (imapping 1 'a 2 'b)) ⇒ ((2 . b) (1 . a))
</code></pre>

<p><code>(imapping-keys</code> <em>imap</em><code>) → list[exact-integer]</code></p>

<p>Returns the keys of <em>imap</em> as a list in ascending numerical order.</p>

<p>Example:</p>

<pre class="example"><code>(imapping-keys (imapping 137 'a -24 'b -5072 'c)) ⇒ (-5072 -24 137)
</code></pre>

<p><code>(imapping-keys-set</code> <em>imap</em><code>) → iset</code></p>

<p>Returns a SRFI 217 integer set containing the keys of <em>imap</em>.</p>

<p>Example:</p>

<pre class="example"><code>(iset-&gt;list (imapping-keys-set (imapping 137 'a -24 'b -5072 'c)))
 ⇒ (-5072 -24 137)
</code></pre>

<p><code>(imapping-values</code> <em>imap</em><code>) → list[*]</code></p>

<p>Returns the elements of <em>imap</em> as a list in ascending numerical
order of key.</p>

<p>Example:</p>

<pre class="example"><code>(imapping-values (imapping 0 "picard" 1 "riker" 2 "troi"))
 ⇒ ("picard" "riker" "troi")
</code></pre>

<h2 id="comparison">Comparison</h2>

<p><code>(imapping=?</code> <em>comp imap</em>₁ <em>imap</em>₂ <em>imap</em>₃ <code>…) → boolean</code></p>

<p>Returns <code>#t</code> if and only if all of the <em>imaps</em> contain equal
associations.  Two associations are equal exactly when their keys are
equal (in the sense of <code>=</code>) and if their values are equal in the sense
of the equality predicate of <em>comp</em> (see
<a href="https://srfi.schemers.org/srfi-128/srfi-128.html">SRFI 128</a>).</p>

<p>Examples:</p>

<pre class="example"><code>(imapping=? (make-default-comparator)
            (imapping 1 'a 2 'b)
            (imapping 2 'b 1 'a))
 ⇒ #t

(imapping=? (make-default-comparator)
            (imapping 1 'a 2 'b 3 'c)
            (imapping 2 'b 1 'a))
 ⇒ #f
</code></pre>

<p><code>(imapping&lt;?</code> <em>comp</em> <em>imap</em>₁ <em>imap</em>₂ <em>imap</em>₃ <code>…) → boolean</code><br>
<code>(imapping&lt;=?</code> <em>comp</em> <em>imap</em>₁ <em>imap</em>₂ <em>imap</em>₃ <code>…) → boolean</code><br>
<code>(imapping&gt;?</code> <em>comp</em> <em>imap</em>₁ <em>imap</em>₂ <em>imap</em>₃ <code>…) → boolean</code><br>
<code>(imapping&gt;=?</code> <em>comp</em> <em>imap</em>₁ <em>imap</em>₂ <em>imap</em>₃ <code>…) → boolean</code></p>

<p>Returns <code>#t</code> if and only if each <em>imap</em> other than the last is a proper
subset/subset/proper superset/superset of the following <em>imap</em>.  Values are
compared using the equality predicate of <em>comp</em>.</p>

<p>Examples:</p>

<pre class="example"><code>(imapping&lt;? (make-default-comparator)
            (imapping 1 'a 2 'b)
            (imapping 2 'b 1 'a 3 'c))
 ⇒ #t

(imapping&gt;? (make-default-comparator)
            (imapping 2 'b 1 "worf" 3 'c)
            (imapping 1 'a 2 'b))
 ⇒ #f

(imapping&gt;=? (make-default-comparator)
             (imapping 2 'b 1 'a 3 'c)
             (imapping 1 'a 2 'b)
             (imapping 2 'b 1 'a)
             (imapping 1 'a))
 ⇒ #t
</code></pre>

<h2 id="settheory">Set theory operations</h2>

<p><code>(imapping-union</code> <em>imap</em>₁ <em>imap</em>₂ <em>imap</em>₃ …<code>) → imapping</code><br>
<code>(imapping-intersection</code> <em>imap</em>₁ <em>imap</em>₂ <em>imap</em>₃ …<code>) → imapping</code><br>
<code>(imapping-difference</code> <em>imap</em>₁ <em>imap</em>₂ <em>imap</em>₃ …<code>) → imapping</code><br>
<code>(imapping-xor</code> <em>imap</em>₁ <em>imap</em>₂<code>) → imapping</code></p>

<p>Return a newly allocated imapping whose set of associations is the
union, intersection, asymmetric difference, or symmetric difference of
the sets of associations of the <em>imaps</em>.  Asymmetric difference is
extended to more than two imappings by taking the difference between
the first imapping and the union of the others.  Symmetric difference
is not extended beyond two imappings.  When comparing associations,
only the keys are compared.  In case of duplicate keys, associations
in the result imapping are drawn from the first imapping in which they
appear.</p>

<p>Examples:</p>

<pre class="example"><code>(imapping-&gt;alist (imapping-union (imapping 0 'a 2 'c)
                                 (imapping 1 'b 3 'd)))
 ⇒ ((0 . a) (1 . b) (2 . c) (3 . d))

(imapping-&gt;alist
 (imapping-intersection (imapping 0 'a 2 'c)
                        (imapping 1 'b 2 'c 3 'd)
                        (imapping 2 'c 4 'e)))
 ⇒ ((2 . c))

(imapping-&gt;alist (imapping-difference (imapping 0 'a 1 'b 2 'c)
                                      (imapping 2 "worf")
                                      (imapping 1 "data")))
 ⇒ ((0 . a))
</code></pre>

<p><code>(imapping-union!</code> <em>imap</em>₁ <em>imap</em>₂ <em>imap</em>₃ …<code>) → imapping</code><br>
<code>(imapping-intersection!</code> <em>imap</em>₁ <em>imap</em>₂ <em>imap</em>₃ …<code>) → imapping</code><br>
<code>(imapping-difference!</code> <em>imap</em>₁ <em>imap</em>₂ <em>imap</em>₃ …<code>) → imapping</code><br>
<code>(imapping-xor!</code> <em>imap</em>₁ <em>imap</em>₂<code>) → imapping</code></p>

<p>These are linear-update variants of
<code>imapping-union</code>, etc..  They are permitted to
mutate <strong>any</strong> of the <em>imap</em> arguments rather than allocating
a new imapping.</p>

<p><code>(imapping-union/combinator</code> <em>proc imap</em>₁ <em>imap</em>₂ <em>imap</em>₃ …<code>) → imapping</code><br>
<code>(imapping-intersection/combinator</code> <em>proc imap</em>₁ <em>imap</em>₂ <em>imap</em>₃ …<code>) → imapping</code></p>

<p><em>proc</em> is a procedure of type <code>* * → *</code>.</p>

<p>Return a new imapping whose set of keys is the union/intersection of
the sets of keys of the <em>imaps</em>.  The values associated with duplicate
keys are combined with <em>proc</em>; that is, if an integer <em>k</em> is associated
with values <em>v</em>₁, <em>v</em>₂, …, <em>v</em>ₙ in <em>imap</em>₁, <em>imap</em>₂, …, <em>imap</em>ₙ,
respectively, then the resulting imapping will contain the association
(<em>k</em>, (<em>proc</em> … (<em>proc v</em>₁ <em>v</em>₂) … <em>v</em>ₙ)).</p>

<p>Examples:</p>

<pre class="example"><code>;; Right-biased union.
(imapping-&gt;alist
 (imapping-union/combinator (lambda (_l r) r)
                            (imapping 1 'b 2 'c)
                            (imapping 2 "data" 3 "picard")))

 ⇒ ((1 . b) (2 . "data") (3 . "picard"))

(imapping-&gt;alist
 (imapping-intersection/combinator
  (lambda (l r) (string-append l " " r))
  (imapping 1 "q" 3 "jean-luc" 5 "miles" 7 "quark")
  (imapping 3 "picard" 5 "o'brien")))

 ⇒ ((3 . "jean-luc picard") (5 . "miles o'brien"))
</code></pre>

<p><code>(imapping-union/combinator!</code> <em>proc imap</em>₁ <em>imap</em>₂ <em>imap</em>₃ …<code>) → imapping</code><br>
<code>(imapping-intersection/combinator!</code> <em>proc imap</em>₁ <em>imap</em>₂ <em>imap</em>₃ …<code>) → imapping</code></p>

<p>These are linear-update variants of <code>imapping-union/combinator</code>
and <code>imapping-intersection/combinator</code>.  They are permitted to
mutate <strong>any</strong> of the <em>imap</em> parameters rather than
allocating a new imapping.</p>

<h2 id="submappings">Submappings</h2>

<p><code>(imapping-open-interval</code> <em>imap low high</em><code>) → imapping</code><br>
<code>(imapping-closed-interval</code> <em>imap low high</em><code>) → imapping</code><br>
<code>(imapping-open-closed-interval</code> <em>imap low high</em><code>) → imapping</code><br>
<code>(imapping-closed-open-interval</code> <em>imap low high</em><code>) → imapping</code></p>

<p><em>low</em> and <em>high</em> are both exact integers.</p>

<p>Procedures that return a subset of <em>imap</em> containing the associations
whose keys are contained in the interval from <em>low</em> to <em>high</em>.  The
interval may be open, closed, open below and closed above, or open
above and closed below.</p>

<p>Examples:</p>

<pre class="example"><code>(imapping-&gt;alist
 (imapping-open-interval (imapping 0 'a 1 'b 2 'c 3 'd) 1 3))
 ⇒ ((2 . c))

(imapping-&gt;alist
 (imapping-closed-interval (imapping 0 'a 1 'b 2 'c 3 'd) 1 3))
 ⇒ ((1 . b) (2 . c) (3 . d))

(imapping-&gt;alist
 (imapping-closed-open-interval (imapping 0 'a 1 'b 2 'c 3 'd) 1 3))
 ⇒ ((1 . b) (2 . c))
</code></pre>

<p><code>(imapping-open-interval!</code> <em>imap low high</em><code>) → imapping</code><br>
<code>(imapping-closed-interval!</code> <em>imap low high</em><code>) → imapping</code><br>
<code>(imapping-open-closed-interval!</code> <em>imap low high</em><code>) → imapping</code><br>
<code>(imapping-closed-open-interval!</code> <em>imap low high</em><code>) → imapping</code></p>

<p>These are linear-update variants of
<code>imapping-open-interval</code>, etc..  They are permitted to
mutate and return the <em>imap</em> argument rather than allocating
a new imapping.</p>

<p><code>(isubmapping=</code> <em>imap k</em><code>) → imapping</code><br>
<code>(isubmapping&lt;</code> <em>imap k</em><code>) → imapping</code><br>
<code>(isubmapping&lt;=</code> <em>imap k</em><code>) → imapping</code><br>
<code>(isubmapping&gt;</code> <em>imap k</em><code>) → imapping</code><br>
<code>(isubmapping&gt;=</code> <em>imap k</em><code>) → imapping</code></p>

<p>Procedures that return an imapping containing the associations of
<em>imap</em> whose keys are equal to, less than/less than or equal
to/greater than/greater than or equal to <em>k</em>.  Note that the result of
<code>isubmapping=</code> contains at most one element.</p>

<p>Examples:</p>

<pre class="example"><code>(imapping-&gt;alist
 (isubmapping= (imapping 0 'a 1 'b 2 'c 3 'd) 2))
 ⇒ ((2 . c))

(imapping-&gt;alist
 (isubmapping&lt; (imapping 0 'a 1 'b 2 'c 3 'd) 2))
 ⇒ ((0 . a) (1 . b))

(imapping-&gt;alist
 (isubmapping&gt;= (imapping 0 'a 1 'b 2 'c 3 'd) 2))
 ⇒ ((2 . c) (3 . d))
</code></pre>

<p><code>(isubmapping=!</code> <em>imap k</em><code>) → imapping</code><br>
<code>(isubmapping&lt;!</code> <em>imap k</em><code>) → imapping</code><br>
<code>(isubmapping&lt;=!</code> <em>imap k</em><code>) → imapping</code><br>
<code>(isubmapping&gt;!</code> <em>imap k</em><code>) → imapping</code><br>
<code>(isubmapping&gt;=!</code> <em>imap k</em><code>) → imapping</code></p>

<p>These are linear-update variants of
<code>isubmapping=</code>, etc..  They are permitted to
mutate and return the <em>imap</em> argument rather than allocating
a new imapping.</p>

<h1 id="implementation">Implementation</h1>

<h1>Acknowledgements</h1>

<p>Thanks to Marc-Nieper Wißkirchen and Arthur A. Gleckler, the
authors of SRFI 146, as well as to Daan Leijen and Andriy Palamarchuk,
who created the Haskell IntMap library.  These libraries provided
critical inspiration and implementation clues in the creation of this
SRFI.</p>

<p>Thanks to the SRFI editor and to the contributors to the SRFI
mailing list.</p>

<h1>References</h1>

<p>Alex Shinn, John Cowan, &amp; Arthur A. Gleckler, eds., &ldquo;Revised<sup>7</sup> Report
on the Algorithmic Language Scheme&rdquo; (R7RS) (2013).  Available
<a href="https://r7rs.org/">on the Web</a>.</p>

<p>Chris Okasaki &amp; Andrew Gill, &ldquo;Fast Mergeable Integer Maps&rdquo;,
1998 <em>Workshop on ML</em>, p. 77-86.</p>

<h1>License</h1>

<p>Copyright &copy; Wolfgang Corcoran-Mathe (2020). All rights reserved.</p>

<p>Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
&ldquo;Software&rdquo;), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:</p>

<p>The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.</p>

<p>THE SOFTWARE IS PROVIDED &ldquo;AS IS&rdquo;, WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>
</body>
</html>
