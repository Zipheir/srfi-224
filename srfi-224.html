<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>SRFI 224: Integer Mappings</title>
  <link href="/favicon.png" rel="icon" sizes="192x192" type="image/png">
  <link rel="stylesheet" href="https://srfi.schemers.org/srfi.css" type="text/css">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>pre.example { margin-left: 2em; }</style>
</head>
<body>
  <h1><a href="https://srfi.schemers.org/"><img class="srfi-logo" src="https://srfi.schemers.org/srfi-logo.svg" alt="SRFI surfboard logo" /></a>224: Integer Mappings</h1>

<p>by Wolfgang Corcoran-Mathe</p>

<h2 id="status">Status</h2>

<p>This SRFI is currently in <em>draft</em> status.  Here is <a href="https://srfi.schemers.org/srfi-process.html">an explanation</a> of each status that a SRFI can hold.  To provide input on this SRFI, please send email to <code><a href="mailto:srfi+minus+224+at+srfi+dotschemers+dot+org">srfi-224@<span class="antispam">nospam</span>srfi.schemers.org</a></code>.  To subscribe to the list, follow <a href="https://srfi.schemers.org/srfi-list-subscribe.html">these instructions</a>.  You can access previous messages via the mailing list <a href="https://srfi-email.schemers.org/srfi-224">archive</a>.</p>
<ul>
  <li>Received: 2021-03-24</li>
  <li>60-day deadline: 2021-05-23</li>
  <li>Draft #1 published: 2021-03-24</li>
  <li>Draft #2 published: 2021-03-29</li>
  <li>Draft #3 published: 2021-04-01</li>
  <li>Draft #4 published: 2021-04-20</li>
  <li>Draft #5 published: 2021-05-12</li>
  <li>Draft #6 published: 2021-05-28</li>
  <li>Wolfgang's <a href="https://github.com/Zipheir/imappings-pre-srfi">personal
       Git repo for this SRFI</a> for reference while the SRFI is in
       <em>draft</em> status (<a href="https://htmlpreview.github.io/?https://github.com/Zipheir/imappings-pre-srfi/blob/main/srfi-224.html">preview</a>)</li>
</ul>

<h2>Abstract</h2>

<p>Integer maps, or <em>imappings</em>, are finite sets, where each element is
an association between an exact-integer key and an arbitrary Scheme
object.  They are similar to the general mappings of
<a href="https://srfi.schemers.org/srfi-146/">SRFI
146</a>, but the restricted key-type allows implementations of
imappings to benefit from optimized structures and algorithms.  This
library provides a rich set of operations on imappings, including
analogues of most of the forms provided by SRFI 146.  Imappings have
no intrinsic order, but may be treated as ordered sets, using the
natural ordering on keys; a substantial sublibrary for working with
imappings in this fashion is included.</p>

<h2>Issues</h2>

<p>Maybe and Either are somewhat controversial in the Scheme community;
should procedures using them be moved to an optional sublibrary?</p>

<h2>Rationale</h2>

<p>&ldquo;Finite maps are the workhorse data structure in every compiler.&rdquo;
—Okasaki &amp; Gill</p>

<p>Mappings provide operations that are critical to a host of functional
algorithms. They describe finite sets of key-value associations (pairs)
which can be extended, queried, and transformed.  Critically,
all of these operations can be efficiently implemented as &ldquo;pure&rdquo;
functions.  While
hash-tables (see <a href="https://srfi.schemers.org/srfi-125/">SRFI 125</a>)
provide similar operations, they generally provide a strictly imperative
language for insertion and mutation of association
sets.</p>

<p>Mappings are already familiar to Scheme programmers;
<a href="https://srfi.schemers.org/srfi-146/">SRFI 146</a> provides general
mappings and was added to the Tangerine Edition of R7RS-large.  But
the generality of SRFI 146 is costly.  Any comparable type of Scheme
object can be used as a key in a SRFI 146 mapping, so comparisons
between keys must use the generic methods of
<a href="https://srfi.schemers.org/srfi-128/">SRFI 128</a>.  This is overkill for
many use-cases; in particular, if we wish to use exact integers as keys,
we expect comparisons to be very fast and to require no mediation
from a comparison dictionary.  In addition,
some efficient and simple mapping representations, for example the
Okasaki-Gill radix tree model used in this SRFI&rsquo;s sample implementation,
are unsuitable for representing general mappings.</p>

<p>The integer mappings we describe restrict the type of keys to
exact integers.  This is a ubiquitous type in computing,
and broadly useful as a key-type for mappings; its use opens up a
range of implementation options.</p>

<p>This library provides an interface similar to that used by
SRFI 146, although it diverges in some areas.  In addition,
<code>imapping-adjust</code>, <code>imapping-alter</code>, and
several other forms derive from Haskell&rsquo;s
<a href="https://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html">IntMap</a>
library.</p>

<p>Many forms make
instrumental use of <a href="https://srfi.schemers.org/srfi-189/">SRFI 189&rsquo;s</a>
Maybe type; I believe that this choice results in simpler,
more compositional definitions.  (Compare, for instance, the
conventional <code>imapping-ref</code> form with
<code>imapping-lookup</code>.)  Using the protocol conversions of
SRFI 189 (<code>maybe-&gt;truth</code>, <code>maybe-&gt;generation</code>, etc.),
procedures that operate on Maybe values can be easily integrated with
traditional Scheme code.
Where the use of Maybe values would clarify nothing, I have preferred the
traditional &ldquo;value or <code>#f</code>&rdquo; Lisp protocol.</p>

<p>The specification of this SRFI depends on the Maybe and Either types
specified in SRFI 189 and on the comparator type (used to determine the
equality of values, not keys) described in
SRFI 128.  Conversions from imappings to
<a href="https://srfi.schemers.org/srfi-158/">SRFI 158</a> generators
are provided.
The sample implementation has further dependencies; see the
<a href="#implementation">appropriate section</a> for more details.</p>

<h2>Specification</h2>

<p>Imappings form a new type, as if created by <code>define-record-type</code>
(see R7RS § 5.5). The effects of using record-type inspection or inheritance
for the imapping type are unspecified.</p>

<p>It is an error to add or remove an association of an imapping while
iterating over it.</p>

<h3>Exact integers</h3>

<p>Scheme implementations that provide arbitrarily large exact integers
usually divide these numbers into two classes: <em>fixnums</em> and
<em>bignums</em>.  (See the R⁶RS § 3.3 and
<a href="https://srfi.schemers.org/srfi-143/">SRFI 143</a>.)  The former
are integers "within a certain implementation-dependent subrange",
typically those that fit in a single word of memory.

<p>Implementations of this SRFI must support fixnum keys, and may restrict
the set of valid keys to the fixnums.</p>

<p>Implementations may support bignum keys.</p>

<h3>Notation</h3>

<p>The words &ldquo;must&rdquo;, &ldquo;may&rdquo;, etc., though not
capitalized in this SRFI, are to be interpreted as described in
<a href="https://tools.ietf.org/html/rfc2119">RFC 2119</a>.</p>

<p>The naming conventions of this document are consistent with those used
in the R7RS Scheme standard.</p>

<p>The following names are used for the parameters of procedures:</p>

<table>
<tr><td><em>obj</em></td><td>Any Scheme object.</td></tr>
<tr><td><em>boolean</em></td><td>A boolean.</td></tr>
<tr><td><em>imap</em></td><td>An integer map (imapping).</td></tr>
<tr><td><em>k</em></td><td>An exact integer.</td></tr>
<tr><td><em>list</em></td><td>A proper list.</td></tr>
<tr><td><em>alist</em></td><td>An association list.</td></tr>
<tr><td><em>proc</em></td><td>A procedure.</td></tr>
<tr><td><em>mproc</em></td><td>A procedure returning a Maybe object.</td></tr>
<tr><td><em>pred</em></td><td>A predicate, assumed to entail no side-effects.</td></tr>
<tr><td><em>comp</em></td><td>A SRFI 128 comparator object.</td></tr>
</table>


<p>It is an error (unless otherwise noted) if the procedures are passed arguments
that do not have the type implied by the argument names.</p>

<p>The pair notation (<em>k</em>,<em>v</em>) is often used to describe
an association of an imapping.  Here, <em>k</em> is the key and
<em>v</em> its associated value.  If an imapping <em>imap</em> is said
to "contain the association (<em>k</em>,<em>v</em>)", then this is to
be understood in the sense that looking up <em>k</em> in <em>imap</em>
(via <code>(imapping-ref</code> <em>imap k</em><code>)</code>, for
example) will produce the value <em>v</em>.</p>

<p>Each procedure is written in the form</p>

<p><code>(</code><em>proc&nbsp;arg₁ arg₂</em> …<code>)</code> → [<em>type</em>₁, <em>type</em>₂, …]</p>

<p>where <em>proc</em> is the name of the procedure, the <em>args</em> are its
parameters, and the <em>types</em> are the types of the objects it returns.
If the procedure returns a single value, the brackets on the right-hand side
may be omitted.
The <em>types</em> refer (informally) to Scheme types; e.g. <code>boolean</code>
denotes a Scheme boolean, <code>list[integer]</code> denotes a list of integers,
etc.  The special notation &lsquo;*&rsquo; indicates that the type
of the value may be anything, depending on the context of the procedure call.
For example, Scheme&rsquo;s <code>list-ref</code> procedure would be written</p>

<p><code>(</code>list-ref <em>list k</em><code>) → *</code></p>

<p>since the type of the return value depends on <em>list</em>.  Multiple
<code>*</code> values appearing in the same type signature do not necessarily
denote the same type.  For example, the signature <code>* * → boolean</code> might
denote the type of a procedure taking two values of the same type to a boolean,
or two values of differing types.  The accompanying description may clarify
the semantics of procedures defined on <code>*</code> values, but Scheme's
type system makes it difficult to explain all of the possible interactions of
these procedures.</p>

<p>A procedure which returns a value of type <em>τ</em><code>-or-false</code>
(where <em>τ</em> denotes a type) returns a <em>τ</em> on success, and
<code>#f</code> otherwise.  Thus the <code>memv</code> procedure of R7RS
would have the type signature <code>* list[*] → list[*]-or-false</code>.</p>

<h3>Linear update</h3>

<p>The procedures of this SRFI, by default, are "pure functional" — they
do not alter their parameters.  However, this SRFI also defines
"linear-update" procedures, all of whose names end in <code>!</code>.
They have hybrid pure/side-effecting semantics: they are allowed,
but not required, to side-effect one of their parameters in
order to construct their result.  An implementation may legally
implement these procedures as pure, side-effect-free functions, or it
may implement them using side effects, depending upon the details of
what is the most efficient or simple to implement in terms of the
underlying representation.</p>

<p>It is an error to rely upon these procedures working by side
effect.  For example, this is not guaranteed to work:</p>

<pre class="example">(let* ((imap1 (imapping 1 'b 2 'c))
       (imap2 (imapping-adjoin! imap1 3 'd)))
  imap1) ; Could be either {(1, b), (2, c)} or {(1, b), (2, c) (3, d)}.
</pre>

<p>However, this is well-defined:</p>

<pre class="example">(let ((imap1 (imapping 1 'b 2 'c)))
  (imapping-adjoin! imap1 3 'd))
</pre>

<p>So clients of these procedures write in a functional style, but
must additionally be sure that, when the procedure is called, there
are no other live references to the potentially-modified imapping
(hence the term "linear update").</p>

<p>There are two benefits to this convention:</p>

<ul><li><p>Implementations are free to provide the most efficient
possible implementation, either functional or side-effecting.</p></li>

<li><p>Programmers may nonetheless continue to assume that imappings are
purely functional data structures: they may be reliably shared without
needing to be copied, uniquified, and so forth.</p></li></ul>

<p>In practice, these procedures are most useful for efficiently
constructing imappings in a side-effecting manner, in some limited local
context, before passing the imapping outside the local construction scope
to be used in a functional manner.</p>

<p>Scheme provides no assistance in checking the linearity of the
potentially side-effected parameters passed to these functions — there's
no linear type checker or run-time mechanism for detecting
violations.</p>

<p>If integer mappings are implemented by immutable structures, then
procedures which return "newly allocated" imappings may
return existing imappings, or imappings which share structure with
existing imappings.  Such an implementation must ensure that
this reuse cannot cause the forms of this library to return incorrect
results.</p>

<h3>Index</h3>

<ul>
<li><p><a href="#constructors">Constructors</a>: <code>imapping, imapping-unfold,
imapping-unfold-maybe, alist-&gt;imapping,
alist-&gt;imapping/combinator</code></p></li>
<li><p><a href="#predicates">Predicates</a>: <code>imapping?, imapping-contains?, imapping-empty?, imapping-disjoint?</code></p></li>
<li><p><a href="#accessors">Accessors</a>: <code>imapping-ref, imapping-ref/default,
imapping-lookup, imapping-min, imapping-max, imapping-lookup-min, imapping-lookup-max</code></p></li>
<li><p><a href="#updaters">Updaters</a>: <code>imapping-adjoin, imapping-adjoin/combinator,
imapping-adjoin!, imapping-adjoin/combinator!, imapping-set, imapping-set!,
imapping-adjust, imapping-adjust!, imapping-delete, imapping-delete!,
imapping-delete-all, imapping-delete-all!, imapping-alter,
imapping-alter!, imapping-update, imapping-update!, imapping-delete-min,
imapping-delete-max, imapping-delete-min!, imapping-delete-max!,
imapping-update-min, imapping-update-max, imapping-update-min!,
imapping-update-max!, imapping-pop-min, imapping-pop-max,
imapping-pop-min!, imapping-pop-max!</code></p></li>
<li><p><a href="#whole">The whole imapping</a>: <code>imapping-size,
imapping-find, imapping-query,
imapping-count, imapping-any?, imapping-every?</code></p></li>
<li><p><a href="#traversal">Traversal</a>: <code>imapping-fold,
imapping-fold-right, imapping-map, imapping-map!, imapping-map-&gt;list,
imapping-map&gt;list, imapping-for-each, imapping-filter-map,
imapping-filter-map!, imapping-map-either, imapping-map-either!,
imapping-relation-map</code></p></li>
<li><p><a href="#filter">Filter</a>: <code>imapping-filter,
imapping-filter!, imapping-remove, imapping-remove!, imapping-partition,
imapping-partition!, imapping-partition</code></p></li>
<li><p><a href="#conversion">Copying and conversion</a>: <code>imapping-copy, imapping-&gt;alist,
imapping-&gt;decreasing-alist, imapping-keys, imapping-values,
imapping-&gt;generator, imapping-&gt;decreasing-generator</code></p></li>
<li><p><a href="#comparison">Comparison</a>: <code>imapping=?, imapping&lt;?, imapping&gt;?, imapping&lt;=?, imapping&gt;=?</code></p></li>
<li><p><a href="#settheory">Set theory operations</a>: <code>imapping-union, imapping-intersection, imapping-difference,
imapping-xor, imapping-union!, imapping-intersection!,
imapping-difference!, imapping-xor!, imapping-union/combinator,
imapping-intersection/combinator, imapping-union/combinator!,
imapping-intersection/combinator!</code></p></li>
<li><p><a href="#submappings">Submappings</a>: <code>imapping-open-interval, imapping-closed-interval,
imapping-open-closed-interval, imapping-closed-open-interval,
imapping-open-interval!, imapping-closed-interval!,
imapping-open-closed-interval!, imapping-closed-open-interval!,
isubmapping=, isubmapping&lt;, isubmapping&lt;=, isubmapping&gt;=,
isubmapping&gt;,
isubmapping=!, isubmapping&lt;!, isubmapping&lt;=!, isubmapping&gt;=!,
isubmapping&gt;!, imapping-split</code></p></li>
</ul>

<h3 id="constructors">Constructors</h3>

<p><code>(imapping</code>&nbsp;<em>k</em>₁ <em>obj</em>₁ <em>k</em>₂ <code>…) → imapping</code></p>

<p>Returns a new imapping.  The arguments alternate between keys (which
must be exact integers) and values (which are arbitrary Scheme objects); the
resulting imapping contains these (<em>k</em>, <em>obj</em>) associations.
The number of arguments must be even.  If duplicate keys occur in
the arguments, earlier associations take priority.</p>

<p>Examples:</p>
<pre class="example"><code>(imapping-&gt;alist (imapping 0 'a 1 'b 2 'c)) ⇒ ((0 . a) (1 . b) (2 . c))
(imapping-&gt;alist (imapping -10 "worf" -10 "yar")) ⇒ ((-10 . "worf"))
</code></pre>

<p><code>(imapping-unfold</code>&nbsp;<em>stop? mapper successor seed</em><code>) → imapping</code></p>

The arguments have the following types:
<ul>
<li><em>stop?</em> : <code>* → *-or-#f</code></li>
<li><em>mapper</em> : <code>* → [exact-integer, *]</code></li>
<li><em>successor</em> : <code>* → *</code></li>
<li><em>seed</em> : <code>*</code></li>
</ul>

<p>Unfold a new imapping from the initial seed value <em>seed</em>.
<em>mapper</em> is applied to each seed and returns two values, a key
and an associated value, which are adjoined to the new imapping.
<em>successor</em> maps each seed to a new seed.
Unfolding terminates when the predicate <em>stop?</em> returns a true
value when applied to the current seed.</p>

<p>Example:</p>
<pre class="example"><code>(imapping-&gt;alist
 (imapping-unfold (lambda (i) (= i 4))
                  (lambda (i) (values i (make-string i #\a)))
                  (lambda (i) (+ i 1))
                  0))
 ⇒ ((0 . "") (1 . "a") (2 . "aa") (3 . "aaa"))
</code></pre>

<p><code>(imapping-unfold-maybe</code>&nbsp;<em>mproc seed</em><code>) → imapping</code></p>

The arguments have the following types:
<ul>
<li><em>mproc</em> : <code>* → maybe[exact-integer, *, *]</code></li>
<li><em>seed</em> : <code>*</code></li>
</ul>

<p>Unfold a new imapping.  <em>mproc</em> is applied to <em>seed</em> and returns
a Maybe value.  If this value is Nothing, then unfolding terminates.
If it is Just <em>k v seed′</em>, then a new association
<code>(</code><em>k</em>, <em>v</em><code>)</code> is added to the resulting imapping and unfolding continues
with <em>seed′</em>.</p>

<p>Example:</p>
<pre class="example"><code>(imapping-&gt;alist
 (imapping-unfold-maybe (lambda (i)
                          (if (&lt; i -3)
                              (nothing)
                              (just i (square i) (- i 1))))
                        -1))
 ⇒ ((-3 . 9) (-2 . 4) (-1 . 1))
</code></pre>

<p><strong>Rationale:</strong> As well as sometimes leading to more compact
expressions than the
traditional "three procedure" unfold, <code>imapping-unfold-maybe</code>
is also more efficient when the programmer wants the value of each new seed
to depend on the computed key and value.  For example,
assume that we apply some procedure <em>f</em> to a seed <em>s</em> to get a
key <em>k</em> and a value <em>v</em>, and that we also want to compute a new
seed from <em>k</em> and <em>v</em>.  Using <em>imapping-unfold</em>, we'd
have no choice other than to compute <em>k</em> and <em>v</em> twice:</p>

<pre class="example"><code>(imapping-unfold stop?
                 f
                 (lambda (s)
                   (let-values (((k v) (f s)))
                     (let ((s* …))
                       s*)))
                 seed)</code></pre>

<p>Using <code>imapping-unfold-maybe</code>, however, it's easy to write an
equivalent unfold which computes <em>k</em> and <em>v</em> only once for
each step:</p>

<pre class="example"><code>(imapping-unfold-maybe (lambda (s)
                         (if (stop? s)
                             (nothing)
                             (let-values (((k v) (f s)))
                               (let ((s* …))
                                 (just k v s*)))))
                       seed)</code></pre>

<p>This may be preferable when <em>f</em> is expensive to apply or entails
side-effects.</p>

<p><code>(alist-&gt;imapping</code>&nbsp;<em>alist</em><code>) → imapping</code></p>

<p>Returns a new imapping containing the associations of <em>alist</em>.
It is an error if the car of any pair in <em>alist</em> is not an
exact integer.  If an integer <em>k</em> appears as the key of multiple
associations in <em>alist</em> (i.e. as the car of multiple pairs),
then the first association for <em>k</em> is preferred.</p>

<p>Example:</p>
<pre class="example"><code>(imapping-&gt;alist (alist-&gt;imapping '((1 . b) (0 . a) (2 . c))))
 ⇒ ((0 . a) (1 . b) (2 . c))

(imapping-&gt;alist (alist-&gt;imapping '((-10 . "yar") (-10 . "worf"))))
 ⇒ ((-10 . "yar))
</code></pre>

<p><code>(alist-&gt;imapping/combinator</code>&nbsp;<em>proc alist</em><code>) → imapping</code></p>

<p><em>proc</em> is a procedure of type <code>* * → *</code>.</p>

<p>Returns a new imapping containing the associations of <em>alist</em>.
It is an error if the car of any pair in <em>alist</em> is not an
exact integer.  If pairs (<em>k</em> . <em>v</em>₁) and
(<em>k</em> . <em>v</em>₂) appear (in that order) in <em>alist</em>, then
the association
(<em>k</em>, (<em>proc v</em>₂ <em>v</em>₁)) is
added to the resulting imapping; in general, if <em>k</em> is associated with
values v₁, v₂, …, vₙ in <em>alist</em>, then <em>k</em> will be associated
with the value of</p>

<pre>(<em>proc v</em>ₙ (<em>proc</em> … (<em>proc v</em>₃ (<em>proc v</em>₂ <em>v</em>₁)) … ))</pre>

<p>in the resulting imapping.</p>

<p>Example:</p>
<pre class="example"><code>(imapping-&gt;alist
 (alist-&gt;imapping/combinator (lambda (x _) x)
                             '((1 . b) (0 . a) (1 . c))))
 ⇒ ((0 . a) (1 . c))
</code></pre>

<h3 id="predicates">Predicates</h3>

<p><code>(imapping?</code>&nbsp;<em>obj</em><code>) → boolean</code></p>

<p>Returns <code>#t</code> if and only if <em>obj</em> is an imapping.</p>

<p><code>(imapping-contains?</code>&nbsp;<em>imap k</em><code>) → boolean</code></p>

<p>Returns <code>#t</code> if and only if <em>imap</em> contains an association for key <em>k</em>.</p>
<p>Examples:</p>
<pre class="example"><code>(imapping-contains? (imapping 1 'b) 1) ⇒ #t
(imapping-contains? (imapping 1 'b) 0) ⇒ #f
</code></pre>

<p><code>(imapping-empty?</code>&nbsp;<em>imap</em><code>) → boolean</code></p>

<p>Returns <code>#t</code> if and only if <em>imap</em> contains no associations.</p>
<p>Examples:</p>
<pre class="example"><code>(imapping-empty? (alist-&gt;imapping '())) ⇒ #t
(imapping-empty? (alist-&gt;imapping '((0 . a)))) ⇒ #f
</code></pre>

<p><code>(imapping-disjoint?</code>&nbsp;<em>imap</em>₁ <em>imap</em>₂<code>) → boolean</code></p>

<p>Returns <code>#t</code> if and only if <em>imap</em>₁ and <em>imap</em>₂ have no keys in common.</p>
<p>Examples:</p>
<pre class="example"><code>(imapping-disjoint? (imapping 0 'a) (imapping 1 'b)) ⇒ #t
(imapping-disjoint? (imapping 1 '(b)) (imapping 1 'b)) ⇒ #f
</code></pre>

<h3 id="accessors">Accessors</h3>

<p><code>(imapping-ref</code>&nbsp;<em>imap k</em><code> [ </code><em>failure</em><code> [ </code><em>success</em><code> ] ]) → *</code></p>

<p>If the optional <em>failure</em> parameter is supplied, then it must
be a procedure of no arguments returning zero or more values of arbitrary
type.  The optional <em>success</em> parameter is a procedure of type
<code>* → *</code>.  <em>failure</em> defaults to a procedure which
signals an error; <em>success</em> defaults to <code>values</code>.</p>

<p>If an association <code>(</code><em>k</em>, <em>v</em><code>)</code> occurs in <em>imap</em>,
tail-calls <em>success</em> on <em>v</em>.  Otherwise, <em>failure</em>
is tail-called on no arguments.</p>

<p>Examples:</p>

<pre class="example"><code>(imapping-ref (imapping 36864 'zap) 36864) ⇒ zap
(imapping-ref (imapping 0 'a) 36864) ⇒ ; error
(imapping-ref (imapping 0 "worf") 0 (lambda () #f) string-length) ⇒ 4
</code></pre>

<p><code>(imapping-ref/default</code>&nbsp;<em>imap k obj</em><code>) → *</code></p>

<p>If an association <code>(</code><em>k</em>, <em>v</em><code>)</code> occurs in <em>imap</em>, returns <em>v</em>.
Otherwise, returns <em>obj</em>.</p>

<p>Examples:</p>

<pre class="example"><code>(imapping-ref/default (imapping 36864 'zap) 36864 #f) ⇒ zap
(imapping-ref/default (imapping 0 'a) 36864 #f) ⇒ #f
</code></pre>

<p><code>(imapping-lookup</code>&nbsp;<em>imap k</em><code>) → maybe[*]</code></p>

<p>If an association <code>(</code><em>k</em>, <em>v</em><code>)</code> occurs in <em>imap</em>, returns Just <em>v</em>.
Otherwise, returns Nothing.</p>
<p>Examples:</p>
<pre class="example">(define (imapping-ref imap k failure success)
  (maybe-ref (imapping-lookup imap k) failure success))

<code>(imapping-lookup (imapping 36864 'zap) 36864) ⇒ just[zap]
(imapping-lookup (imapping 0 'a) 36864) ⇒ nothing
</code></pre>

<p><code>(imapping-lookup-min</code>&nbsp;<em>imap</em><code>) → maybe[exact-integer, *]</code></p>

<p>Returns Just <em>k</em> <em>v</em>, where <em>k</em> is the least key of <em>imap</em>.
If <em>imap</em> is empty in the sense of <code>imapping-empty?</code>, returns
Nothing.</p>

<p>Examples:</p>

<pre class="example"><code>(maybe-&gt;list-truth
 (imapping-lookup-min (imapping 0 'a 1 'b 2 'c))) ⇒ (0 a)
(imapping-lookup-min (imapping)) ⇒ nothing
</code></pre>

<p><code>(imapping-min</code>&nbsp;<em>imap</em><code>) → [exact-integer, *]</code></p>

<p>Returns two values: the least key of <em>imap</em> and its
associated value. It is an error if <em>imap</em> is empty.</p>

<p>Example:</p>

<pre class="example"><code>(imapping-min (imapping 0 'a 1 'b 2 'c)) ⇒ 0 a
</code></pre>

<p><code>(imapping-lookup-max</code>&nbsp;<em>imap</em><code>) → maybe[exact-integer, *]</code></p>

<p>Returns Just <em>k</em> <em>v</em>, where <em>k</em> is the greatest key of <em>imap</em>.
If <em>imap</em> is empty in the sense of <code>imapping-empty?</code>, returns
Nothing.</p>

<p>Examples:</p>

<pre class="example"><code>(maybe-&gt;list-truth
 (imapping-lookup-max (imapping 0 'a 1 'b 2 'c))) ⇒ (2 c)
(imapping-lookup-max (imapping)) ⇒ nothing
</code></pre>

<p><code>(imapping-max</code>&nbsp;<em>imap</em><code>) → [exact-integer, *]</code></p>

<p>Returns two values: the greatest key of <em>imap</em> and its
associated value. It is an error if <em>imap</em> is empty.</p>

<p>Example:</p>

<pre class="example"><code>(imapping-max (imapping 0 'a 1 'b 2 'c)) ⇒ 2 c
</code></pre>

<h3 id="updaters">Updaters</h3>

<p><code>(imapping-adjoin</code>&nbsp;<em>imap k</em>₁ <em>obj</em>₁ <em>k</em>₂ <code>…) → imapping</code></p>

<p>Returns a new imapping containing all of the associations of
<em>imap</em> as well as the associations (<em>k</em>₁, <em>obj</em>₁),
(<em>k</em>₂, <em>obj</em>₂), ….
The number of key/value arguments must be even.</p>

<p>If any of the keys already have associations in <em>imap</em>, the old
associations are preserved.</p>

<p>Examples:</p>

<pre class="example"><code>(imapping-&gt;alist (imapping-adjoin (imapping 1 'b) 0 'a)) ⇒ ((0 . a) (1 . b))
</code></pre>

<p><code>(imapping-adjoin!</code>&nbsp;<em>imap k</em>₁ <em>obj</em>₁ <em>k</em>₂ <code>…) → imapping</code></p>

<p><code>imapping-adjoin!</code> is the same as <code>imapping-adjoin</code>,
except that it may mutate and return the <em>imap</em> argument instead of
allocating a new imapping.</p>

<p><code>(imapping-adjoin/combinator</code>&nbsp;<em>imap proc k</em>₁ <em>obj</em>₁ <em>k</em>₂ <code>…)</code></p>

<p>Similar to <code>imapping-adjoin</code>, except that duplicate associations
are combined with <em>proc</em>, which is a procedure of type <code>* * → *</code>.
<em>proc</em> is called on the new and old values (in that order) associated
with a duplicated key and is expected to return a value for the key.</p>

<p>Example:</p>

<pre class="example"><code>(imapping-&gt;alist
 (imapping-adjoin/combinator (imapping 0 "geordi" 1 "reginald")
                             (lambda (last first)
                               (string-append first " " last))
                             0 "laforge"
                             1 "barclay"))
 ⇒ ((0 . "geordi laforge") (1 . "reginald barclay"))
</code></pre>

<p><code>(imapping-adjoin/combinator!</code>&nbsp;<em>imap proc k</em>₁ <em>obj</em>₁ <em>k</em>₂ <code>…)</code></p>

<p><code>imapping-adjoin/combinator!</code> is the same as
<code>imapping-adjoin/combinator</code>, except that it may
mutate and return the <em>imap</em> argument instead of
allocating a new imapping.</p>

<p><code>(imapping-set</code>&nbsp;<em>imap k</em>₁ <em>obj</em>₁ <em>k</em>₂ <code>…) → imapping</code></p>

<p><code>imapping-set</code> is the same as <code>imapping-adjoin</code>,
except that any existing associations for <em>k</em>₁, <em>k</em>₂, … are
replaced.</p>

<p>Example:</p>

<pre class="example"><code>(imapping-&gt;alist
 (imapping-set (imapping 0 "geordi" 1 "reginald") 1 "tasha"))
 ⇒ ((0 . "geordi") (1 . "tasha"))
</code></pre>

<p><code>(imapping-set!</code>&nbsp;<em>imap k</em>₁ <em>obj</em>₁ <em>k</em>₂ <code>…) → imapping</code></p>

<p><code>imapping-set!</code> is the same as <code>imapping-set</code>,
except that it may mutate and return the <em>imap</em> parameter instead of
allocating a new imapping.</p>

<p><code>(imapping-adjust imap k proc) → imapping</code></p>

<p>The <em>proc</em> parameter of <code>imapping-adjust</code> is a
procedure of type <code>exact-integer * → *</code>.</p>

<p>Returns a new imapping in which the association (<em>k</em>, <em>v</em>) in <em>imap</em>
is replaced by (<em>k</em>, (<em>proc k v</em>)).  If <em>k</em> has
no association in <em>imap</em>,
then a copy of <em>imap</em> is returned.</p>

<p>Examples:</p>

<pre class="example"><code>(imapping-&gt;alist
 (imapping-adjust (imapping 64 "var")
                  64
                  (lambda (k s) (string-append s (number-&gt;string k)))))
 ⇒ ((64 . "var64"))
</code></pre>

<p><code>(imapping-adjust! imap k proc) → imapping</code></p>

<p><code>imapping-adjust!</code> is the same as
<code>imapping-adjust</code>, except that it may
mutate and return the <em>imap</em> argument instead of
allocating a new imapping.</p>

<p><code>(imapping-delete imap</code>&nbsp;<em>k</em>₁ <em>k</em>₂ <code>…) → imapping</code></p>

<p>Returns a new imapping with the same associations as <em>imap</em>, except
those for keys equal to <em>k</em>₁, <em>k</em>₂, ….  If a key does not have an
association in <em>imap</em>, it is ignored.</p>

<p>Example:</p>

<pre class="example"><code>(imapping-&gt;alist (imapping-delete (imapping 0 -200 1 -100) 0)) ⇒ ((1 . -100))
</code></pre>

<p><code>(imapping-delete! imap</code>&nbsp;<em>k</em>₁ <em>k</em>₂ <code>…) → imapping</code></p>

<p><code>imapping-delete!</code> is the same as
<code>imapping-delete</code>, except that it may
mutate and return the <em>imap</em> argument instead of
allocating a new imapping.</p>

<p><code>(imapping-delete-all</code>&nbsp;<em>imap list</em><code>) → imapping</code></p>

<p>Returns a new imapping with the same associations as <em>imap</em>, except
those for keys equal to an element of <em>list</em>.</p>

<p>Example:</p>

<pre class="example"><code>(imapping-&gt;alist (imapping-delete-all (imapping 0 'a 1 'b 2 'c) '(1 2)))
 ⇒ ((0 . a))
</code></pre>

<p><code>(imapping-delete-all!</code>&nbsp;<em>imap list</em><code>) → imapping</code></p>

<p><code>imapping-delete-all!</code> is the same as
<code>imapping-delete-all</code>, except that it may
mutate and return the <em>imap</em> argument instead of
allocating a new imapping.</p>

<p><code>(imapping-update</code>&nbsp;<em>imap k mproc</em><code>) → imapping</code></p>

<p><em>mproc</em> is a procedure of type
<code>exact-integer * → maybe[*]</code>.</p>

<p>Returns a new imapping with the same associations as <em>imap</em>, except
that the association for <em>k</em> is updated as follows.  <em>mproc</em> is
applied to <em>k</em> and its associated value.
If it returns Nothing, the association is deleted;
if it returns Just <em>v</em>, then <code>(</code><em>k</em>, <em>v</em><code>)</code> is added to the new imapping.
If <em>k</em> has no association in <em>imap</em>, then a copy of <em>imap</em>
is returned.</p>

<p>Simple versions of several other update operations may be defined
in terms of <code>imapping-update</code>, e.g.:</p>

<pre><code>  (imapping-delete imap k)
   ≡
  (imapping-update imap k (lambda (_k _v) (nothing)))

  (imapping-set imap k v)
   ≡
  (imapping-update imap k (lambda (_k _v) (just v)))
</code></pre>
<p>Examples:</p>

<pre class="example"><code>;; Delete the association for 1 if its value is a symbol.
(imapping-&gt;alist
 (imapping-update (imapping 0 'a 1 'b 2 'c)
                  1
                  (lambda (_k v)
                    (if (symbol? v)
                        (nothing)
                        (just v)))))
 ⇒ ((0 . a) (2 . c))

;; Replace the value associated with 1.
(imapping-&gt;alist
 (imapping-update (imapping 0 'a 1 'b 2 'c) 1 (lambda (k _v) (just k))))
 ⇒ ((0 . a) (1 . 1) (2 . c))
</code></pre>

<p><code>(imapping-update!</code>&nbsp;<em>imap k mproc</em><code>) → imapping</code></p>

<p><code>imapping-update!</code>
is the same as <code>imapping-update</code>, except that it may
mutate and return the <em>imap</em> argument instead of
allocating a new imapping.</p>

<p><code>(imapping-alter</code>&nbsp;<em>imap k proc</em><code>) → imapping</code></p>

<p><em>proc</em> is a procedure of type
<code>maybe[exact-integer, *] → maybe[*]</code>.</p>

<p>Returns a new imapping with the same associations as <em>imap</em>, except
that the association, or lack thereof, for <em>k</em> is updated as follows.
If the association <code>(</code><em>k</em>, <em>v</em><code>)</code> exists in <em>imap</em>, then <em>proc</em> is called on
Just <em>k v</em>; if no such association exists, then <em>proc</em> is called on
Nothing.  If the result of this application is Nothing, the
association is deleted (or no new association is added); if the result
is Just <em>v′</em>, a new association <em>(k, v′)</em> is added to the new
imapping, replacing any old association for <em>k</em>.</p>

<p><code>imapping-alter</code> is a very general operator on imappings, and most
of the other update operations may be defined in terms of it.  For
example:</p>

<pre><code>  (imapping-update imap k f)
   ≡
  (imapping-alter imap k (lambda (m)
                           (maybe-ref m nothing f))
</code></pre>

<p>Examples:</p>

<pre class="example"><code>;; Insert an association for 4 if it's not present.
(imapping-&gt;alist
 (imapping-alter (imapping 0 'a 1 'b)
                 4
                 (lambda (m)
                   (if (nothing? m) (just 'e) m))))
 ⇒ ((0 . a) (1 . b) (4 . e))

;; Delete an association for 1 if its value is a symbol.
(imapping-&gt;alist
 (imapping-alter (imapping 0 'a 1 'b)
                 1
                 (lambda (m)
                   (maybe-bind m (lambda (_ v)
                                   (if (symbol? v)
                                       (nothing)
                                       (just v)))))))
 ⇒ ((0 . a))
</code></pre>

<p><code>(imapping-alter!</code>&nbsp;<em>imap k proc</em><code>) → imapping</code></p>

<p><code>imapping-alter!</code> is the same as
<code>imapping-alter</code>, except that it may
mutate and return the <em>imap</em> argument instead of
allocating a new imapping.</p>

<p><code>(imapping-delete-min</code>&nbsp;<em>imap</em><code>) → imapping</code><br>
<code>(imapping-delete-max</code>&nbsp;<em>imap</em><code>) → imapping</code></p>

<p>Returns a new imapping with the same associations as <em>imap</em>, except
for the association with the least/greatest key.  If <em>imap</em> is empty,
an error is signalled.</p>

<p><code>(imapping-delete-min!</code>&nbsp;<em>imap</em><code>) → imapping</code><br>
<code>(imapping-delete-max!</code>&nbsp;<em>imap</em><code>) → imapping</code></p>

<p><code>imapping-delete-min!</code> and <code>imapping-delete-max!</code>
are the same as <code>imapping-delete-min</code> and
<code>imapping-delete-max</code>, respectively, except that they may
mutate and return the <em>imap</em> argument instead of
allocating a new imapping.</p>

<p>Examples:</p>

<pre class="example"><code>(imapping-delete-min (imapping 0 'a 1 'b 2 'c)) ⇒ ((1 . b) (2 . c))
(imapping-delete-max (imapping 0 'a 1 'b 2 'c)) ⇒ ((0 . a) (1 . b))
</code></pre>

<p><code>(imapping-update-min</code>&nbsp;<em>imap mproc</em><code>) → imapping</code><br>
<code>(imapping-update-max</code>&nbsp;<em>imap mproc</em><code>) → imapping</code></p>

<p>The <em>mproc</em> argument of <code>imapping-update-min</code> and <code>-max</code> is of
type <code>exact-integer * → maybe[*]</code>.</p>

<p>Returns a new imapping with the same associations as <em>imap</em>, except
that the association for the least/greatest key <em>k</em> is updated as
follows.  <em>mproc</em> is applied to <em>k</em> and its associated value and is
expected to return a Maybe value.  If it returns Nothing, the
association is deleted; if it returns Just <em>v</em>, then <code>(</code><em>k</em>, <em>v</em><code>)</code> is added
to the new imapping.  If <em>imap</em> is empty, an error is signaled.</p>

<p>Examples:</p>

<pre class="example"><code>(imapping-&gt;alist
 (imapping-update-min (imapping -5 "phaser" -1 "tricorder")
                      (lambda (_ v)
                        (if (symbol? v)
                            (just v)
                            (nothing)))))
 ⇒ ((-1 . "tricorder"))

(imapping-&gt;alist
 (imapping-update-max (imapping -5 "phaser" -1 "tricorder")
                      (lambda (k v)
                        (if (and (negative? k) (string? v))
                            (just (string-length v))
                            (nothing)))))
 ⇒ ((-5 . "phaser") (-1 . 9))
</code></pre>

<p><code>(imapping-update-min!</code>&nbsp;<em>imap mproc</em><code>) → imapping</code><br>
<code>(imapping-update-max!</code>&nbsp;<em>imap mproc</em><code>) → imapping</code></p>

<p>These are linear-update variants of
<code>imapping-update-min</code> and <code>imapping-update-max</code>.  They may
mutate and return the <em>imap</em> argument instead of allocating
a new imapping.</p>

<p><code>(imapping-pop-min</code>&nbsp;<em>imap</em><code>) → maybe[exact-integer, *, imapping]</code><br>
<code>(imapping-pop-max</code>&nbsp;<em>imap</em><code>) → maybe[exact-integer, *, imapping]</code></p>

<p>Returns Just <em>k v imap′</em>, where (<em>k</em>, <em>v</em>) is the association of
<em>imap</em> with the least/greatest key and <em>imap′</em> is a newly-allocated
imapping containing all of the associations of <em>imap</em> except for
(<em>k</em>, <em>v</em>).  If <em>imap</em> is empty, returns Nothing.</p>

<p>Example:</p>

<pre class="example"><code>(maybe-&gt;list-truth
 (maybe-let*-values (((k v imap)
                      (imapping-pop-min (imapping 0 'a 1 'b 2 'c))))
   (values k v (imapping-&gt;alist imap))))
 ⇒ (0 a ((1 . b) (2 . c)))
</code></pre>

<p><code>(imapping-pop-min!</code>&nbsp;<em>imap</em><code>) → maybe[exact-integer, *, imapping]</code><br>
<code>(imapping-pop-max!</code>&nbsp;<em>imap</em><code>) → maybe[exact-integer, *, imapping]</code></p>

<p><code>imapping-pop-min!</code> and <code>imapping-pop-max!</code>
are the same as <code>imapping-pop-min</code> and
<code>imapping-pop-max</code>, respectively, except that they may
mutate and return the <em>imap</em> argument instead
of allocating a new imapping.</p>

<h3 id="whole">The whole imapping</h3>

<p><code>(imapping-size</code>&nbsp;<em>imap</em><code>) → exact-integer</code></p>

<p>Returns the number of associations in <em>imap</em>.</p>

<p><code>(imapping-find</code>&nbsp;<em>pred imap failure</em><code>)</code> → <code>[exact-integer, *] or [*, …]</code></p>

<p><em>pred</em> is a predicate of type <code>exact-integer * → boolean</code>.
<code>failure</code> is a procedure of no arguments returning zero
or more values of arbitrary type.</p>

<p>Returns two values, <em>k</em> and <em>v</em>, where
(<em>k</em>, <em>v</em>) is the association of <em>imap</em> with the
least key such that <code>(</code><em>pred k v</em><code>)</code> is true.
If there is no
such association, then <em>failure</em> is tail-called with no
arguments and its results are returned.</p>

<p>Examples:</p>

<pre class="example"><code>(imapping-find (lambda (_ v) (even? v))
               (imapping 0 1 1 2 2 4 3 8)
               (lambda () (values #f #f)))
 ⇒ 1 2

(imapping-find (lambda (_ v) (negative? v))
               (imapping 0 1 1 2 2 4 3 8)
               (lambda () (values 'nope 'nada)))
 ⇒ nope nada

(imapping-find (lambda (k s) (= k (string-length s)))
               (imapping 2 "worf" 3 "data" 4 "troi")
               (lambda () (error "not found")))
 ⇒ 4 "troi"
</code></pre>

<p><code>(imapping-query</code>&nbsp;<em>pred imap</em><code>) → maybe[exact-integer, *]</code></p>

<p><em>pred</em> is a predicate of type
<code>exact-integer * → boolean</code>.</p>

<p>Returns Just <em>k v</em>, where (<em>k</em>, <em>v</em>) is the
association of <em>imap</em> with the least key <em>k</em> such that
<code>(</code><em>pred k v</em><code>)</code> is true, or Nothing if
there is no such association.</p>

<p>Examples:</p>

<pre class="example"><code>;; Simulating imapping-lookup
(maybe-&gt;list-truth
 (imapping-query (lambda (_ s) (equal? s "guinan"))
                 (imapping 11 "ro" 13 "guinan" 17 "barclay")))
 ⇒ (13 "guinan")

(maybe-&gt;list-truth
 (imapping-query (lambda (k v)
                   (and (positive? k) (integer? v)))
                 (alist->imapping '((-3 . 80) (0 . 1/3) (3 . 7+2i)))))
 ⇒ #f
</code></pre>

<p><code>(imapping-count</code>&nbsp;<em>pred imap</em><code>) → exact-integer</code></p>

<p><em>pred</em> is a predicate of type
<code>exact-integer * → boolean</code>.</p>

<p>Returns the number of associations in <em>imap</em> that satisfy
<em>pred</em> (in the sense of <code>imapping-find</code>).</p>

<p>Examples:</p>

<pre class="example"><code>(imapping-count (lambda (_ v) (even? v))
                (imapping 0 1 1 2 2 4 3 8)) ⇒ 3
(imapping-count (lambda (k s) (= k (string-length s)))
                (imapping 0 "x" 1 "y" 2 "z"))
 ⇒ 1
</code></pre>

<p><code>(imapping-any?</code>&nbsp;<em>pred imap</em><code>) → boolean</code></p>

<p><em>pred</em> is a predicate of type
<code>exact-integer * → boolean</code>.</p>

<p>Returns <code>#t</code> if and only if there exists an association
in <em>imap</em> that satisfies <em>pred</em> (in the sense of
<code>imapping-find</code>).  <em>imap</em> is traversed in ascending
numerical order of keys.</p>

<p>Example:</p>

<pre class="example"><code>(imapping-any? (lambda (_ v) (odd? v))
               (imapping 0 1 1 2 2 4 3 8)) ⇒ #t
</code></pre>

<p><code>(imapping-every?</code>&nbsp;<em>pred imap</em><code>) → boolean</code></p>

<p><em>pred</em> is a predicate of type
<code>exact-integer * → boolean</code>.</p>

<p>Returns <code>#t</code> if and only every association in
<em>imap</em> satisfies <em>pred</em> (in the sense of
<code>imapping-find</code>), or if <em>imap</em> is empty.
<em>imap</em> is traversed in ascending numerical order of keys.</p>

<p>Example:</p>

<pre class="example"><code>(imapping-every? (lambda (_ v) (integer? v))
                 (imapping 0 1 1 2 2 4 3 8)) ⇒ #t
</code></pre>

<h3 id="traversal">Traversal</h3>

<p><code>(imapping-map</code>&nbsp;<em>proc imap</em><code>) → imapping</code></p>

<p>The <em>proc</em> argument of <code>imapping-map</code> is of type
<code>exact-integer * → *</code>.</p>

<p>Returns a new imapping.  For each association
<code>(</code><em>k, v</em><code>)</code> in <em>imap</em>, the association
<code>(</code><em>k</em><code>, (</code><em>proc k v</em><code>))</code>
is added to the new imapping.
The dynamic order
of the applications of <em>proc</em> to the elements of <em>imap</em> is
unspecified.</p>

<p>Examples:</p>

<pre class="example"><code>(imapping-&gt;alist
 (imapping-map (lambda (_ s) (string-length s))
               (imapping 0 "picard" 1 "riker" 2 "troi")))
 ⇒ ((0 . 6) (1 . 5) (2 . 4))

(imapping-&gt;alist
 (imapping-map (lambda (k s)
                 (string-append s (number-&gt;string k)))
               (imapping 256 "x" 512 "y" 1024 "z")))
 ⇒ ((256 . "x256") (512 . "y512") (1024 . "z1024"))
</code></pre>

<p>Note that, in contrast to SRFI 146&rsquo;s <code>mapping-map</code>
procedure, this procedure transforms the values of <em>imap</em> only;
that is, the set of keys of the resulting imapping is the same as that
of <em>imap</em>.</p>

<p><code>(imapping-map!</code>&nbsp;<em>proc imap</em><code>) → imapping</code></p>

<p><code>imapping-map!</code>
is the same as <code>imapping-map</code>, except that it may
mutate and return the <em>imap</em> argument instead of
allocating a new imapping.</p>

<p><code>(imapping-for-each</code>&nbsp;<em>proc imap</em><code>) → unspecified</code></p>

<p><em>proc</em> is a procedure of type <code>exact-integer * → *</code>.

<p>Calls <em>proc</em> on the key and value of each association in <em>imap</em> and returns
an unspecified value.  <em>imap</em> is traversed in ascending numerical
order of keys.</p>

<p>Example:</p>

<pre class="example"><code>(let ((sum 0))
  (imapping-for-each (lambda (_ v) (set! sum (+ sum v)))
                     (imapping 0 1 1 2 2 4 3 8))
  sum)
 ⇒ 15
</code></pre>

<p><code>(imapping-fold</code>&nbsp;<em>kons knil imap</em><code>) → *</code><br>
<code>(imapping-fold-right</code>&nbsp;<em>kons knil imap</em><code>) → *</code></p>

<p>The <em>kons</em> argument of <code>imapping-fold</code> and <code>imapping-fold-right</code> is a
procedure of type <code>exact-integer * * → *</code>.
<em>knil</em> can be any object.</p>

<p>Folds <em>kons</em> over <em>imap</em>, using <em>knil</em> as the base value.  At
each step, <em>kons</em> is applied to the key of an association, its
associated value, and to the result of the last application.
<code>imapping-fold</code> folds in ascending numerical order of keys;
<code>imapping-fold-right</code> folds in descending order.</p>

<p>Examples:</p>

<pre class="example"><code>(imapping-fold-right (lambda (_ v vs) (cons v vs))
                     '()
                     (imapping 0 "worf" 1 "data" 2 "crusher"))
 ⇒ ("worf" "data" "crusher")

(imapping-fold (lambda (k _ ks) (cons k ks))
               '()
               (imapping 0 "worf" 1 "data" 2 "crusher"))
 ⇒ (2 1 0)
</code></pre>

<p><code>(imapping-map-&gt;list</code>&nbsp;<em>proc imap</em><code>) → list</code></p>

<p>Efficient fusion of <code>(imapping-values (imapping-map</code>&nbsp;<em>proc imap</em><code>))</code>.</p>

<p>Example:</p>

<pre class="example"><code>(imapping-&gt;alist
 (imapping-map-&gt;list (lambda (_ v) (string-length v))
                     (imapping 0 "picard" 1 "riker" 2 "troi")))
 ⇒ (6 5 4)
</code></pre>

<p><code>(imapping-filter-map</code>&nbsp;<em>proc imap</em><code>) → imapping</code></p>

<p>The <em>proc</em> parameter of <code>imapping-filter-map</code> is a
procedure of type <code>exact-integer * → *-or-#f</code>.</p>

<p><code>imapping-filter-map</code> is similar to <code>imapping-map</code>,
but only associations for which <em>proc</em> returns a true value are
added to the new imapping.</p>

<p>Example:</p>

<pre class="example"><code>(imapping-&gt;alist
 (imapping-filter-map (lambda (v)
                        (and (positive? v) (square v)))
                      (imapping 0 2 1 -4 2 8)))
 ⇒ ((0 . 4) (2 . 64))
</code></pre>

<p><code>(imapping-filter-map!</code>&nbsp;<em>proc imap</em><code>) → imapping</code></p>

<p><code>imapping-filter-map!</code> is the same as
<code>imapping-filter-map</code>, except that it may
mutate and return the <em>imap</em> argument instead of
allocating a new imapping.</p>

<p><code>(imapping-map-either</code>&nbsp;<em>proc imap</em><code>) → [imapping, imapping]</code></p>

<p>The <em>proc</em> of <code>imapping-map-either</code> is a
procedure of type <code>exact-integer * → either[*]</code>, where
<code>either[*]</code> denotes a SRFI 189 Either containing a single
value.</p>

<p><code>imapping-map-either</code> maps <em>proc</em> over the associations
of <em>imap</em> and returns imappings of the Left and of the Right
results.  For each association (<em>k</em>, <em>v</em>) in
<em>imap</em>, (<em>proc k v</em>) is evaluated.  If the result is a
Left of a value <em>v</em>₁, then the association (<em>k</em>,
<em>v</em>₁) is added to the first new imapping.  If it is instead a
Right of <em>v</em>₂, then the association (<em>k</em>, <em>v</em>₂)
is added to the second new imapping.</p>

<p>Example:</p>

<pre class="example"><code>(let-values (((lefts rights)
              (imapping-map-either
               (lambda (_ v)
                 (if (&gt;= v 0)
                     (right v)
                     (left v)))
               (imapping 0 -50 4 -25 8 25 12 50))))
  (values (imapping-&gt;alist lefts)
          (imapping-&gt;alist rights)))
 ⇒ ((0 . -50) (4 . -25))
   ((8 . 25) (12 . 50))
</code></pre>

<p><code>(imapping-map-either!</code>&nbsp;<em>proc imap</em><code>) → imapping imapping</code></p>

<p><code>imapping-map-either!</code> is the same as
<code>imapping-map-either</code>, except that it may mutate the
<em>imap</em> parameter to produce their results.</p>

<p><code>(imapping-relation-map</code>&nbsp;<em>proc imap</em><code>) → imapping</code></p>

<p><em>proc</em> must be a procedure of type
<code>exact-integer * → [exact-integer, *]</code>.</p>

<p>Returns a new imapping whose associations are the results of
transforming both the keys and the values of <em>imap</em> with
<em>proc</em>.  For each association (<em>k</em>,
<em>v</em>) in <em>imap</em>, (<em>proc k v</em>) is evaluated to
return a new key and a new value which are associated in the new
imapping.  Duplicate keys are replaced, but the results in this case
are unpredictable; if <em>proc</em> is not injective, that is, if it
produces multiple associations with the same key, then it is unspecified
which one of these associations will be present in the resulting
imapping. The dynamic order of the applications of <em>proc</em> to the
elements of <em>imap</em> is unspecified.</p>

<p><strong>Rationale:</strong> <code>imapping-relation-map</code>
corresponds to <code>mapping-map</code> from SRFI 146 and is specified
primarily for compatibility with that SRFI.  It generalizes
<code>imapping-map</code>, and can
be used to produce a wide range of transformations on imappings.  This
generality comes at a price, however.  Certain familiar laws that hold
of <code>imapping-map</code> and other Scheme "map" functions do not
hold of <code>imapping-relation-map</code>; in particular, the size of
the input imapping <em>imap</em> may not be preserved, and a key with an
association in <em>imap</em> may not have an association in the
transformed imapping.</p>

<p>As such, <code>imapping-map</code>
likely conforms better to the familiar pattern of Scheme "map" functions,
while being sufficiently general for most purposes.</p>

<h3 id="filter">Filter</h3>

<p><code>(imapping-filter</code>&nbsp;<em>pred imap</em><code>) → imapping</code></p>

<p>Returns a new imapping containing all of the associations of <em>imap</em>
that satisfy <em>pred</em> (in the sense of <code>imapping-find</code>).</p>

<p>Example:</p>

<pre class="example"><code>(imapping-&gt;alist
 (imapping-filter (lambda (_ v) (positive? v))
                  (imapping 0 2 1 -4 2 8 3 -16)))
 ⇒ ((0 . 2) (2 . 8))
</code></pre>

<p><code>(imapping-filter!</code>&nbsp;<em>pred imap</em><code>) → imapping</code></p>

<p><code>imapping-filter!</code> is the same as
<code>imapping-filter</code>, except that it may mutate and return the
<em>imap</em> parameter instead of allocating a new imapping.</p>

<p><code>(imapping-remove</code>&nbsp;<em>pred imap</em><code>) → imapping</code></p>

<p>Returns a new imapping containing all of the associations of
<em>imap</em> that do not satisfy <em>pred</em> (in the sense of
<code>imapping-find</code>).</p>

<p>Example:</p>

<pre class="example"><code>(imapping-&gt;alist
 (imapping-remove (lambda (_ v) (positive? v))
                  (imapping 0 2 1 -4 2 8 3 -16)))
 ⇒ ((1 . -4) (3 . -16))
</code></pre>

<p><code>(imapping-remove!</code>&nbsp;<em>pred imap</em><code>) → imapping</code></p>

<p><code>imapping-remove!</code>
is the same as <code>imapping-remove</code>, except that it may
mutate and return the <em>imap</em> parameter instead of
allocating a new imapping.</p>

<p><code>(imapping-partition</code>&nbsp;<em>pred imap</em><code>) → [imapping, imapping]</code></p>

<p>Returns two new imappings: the first contains all associations of
<em>imap</em> that satisfy <em>pred</em> (in the sense of
<code>imapping-find</code>), and the second contains those
that do not.</p>

<p>Example:</p>

<pre class="example"><code>(let-values (((pos ~pos)
              (imapping-partition (lambda (_ v) (positive? v))
                                  (imapping 0 2 1 -4 2 8 3 -16))))
  (values (imapping-&gt;alist pos)
          (imapping-&gt;alist ~pos)))
 ⇒ ((0 . 2) (2 . 8))
   ((1 . -4) (3 . -16))
</code></pre>

<p><code>(imapping-partition!</code>&nbsp;<em>pred imap</em><code>) → [imapping, imapping]</code></p>

<p><code>imapping-partition!</code>
is the same as <code>imapping-partition</code>, except that it may
mutate the <em>imap</em> parameter to produce its results.</p>

<h3 id="conversion">Copying and conversion</h3>

<p><code>(imapping-copy</code>&nbsp;<em>imap</em><code>) → imapping</code></p>

<p>Returns a newly allocated imapping containing the associations of
<em>imap</em>.</p>

<p>In an implementation with immutable imappings, <code>imapping-copy</code>
may simply return <em>imap</em>.</p>

<p><code>(imapping-&gt;alist</code>&nbsp;<em>imap</em><code>) → alist[exact-integer, *]</code></p>

<p>Returns a car/cdr alist containing the associations of <em>imap</em> in
ascending numerical order of keys.</p>

<p>Example:</p>

<pre class="example"><code>(imapping-&gt;alist (imapping 1 'a 2 'b)) ⇒ ((1 . a) (2 . b))
</code></pre>

<p><code>(imapping-&gt;decreasing-alist</code>&nbsp;<em>imap</em><code>) → alist[exact-integer, *]</code></p>

<p>Returns a car/cdr alist containing the associations of <em>imap</em> in
decreasing numerical order of keys.</p>

<p>Example:</p>

<pre class="example"><code>(imapping-&gt;alist (imapping 1 'a 2 'b)) ⇒ ((2 . b) (1 . a))
</code></pre>

<p><code>(imapping-keys</code>&nbsp;<em>imap</em><code>) → list[exact-integer]</code></p>

<p>Returns the keys of <em>imap</em> as a list in ascending numerical order.</p>

<p>Example:</p>

<pre class="example"><code>(imapping-keys (imapping 137 'a -24 'b -5072 'c)) ⇒ (-5072 -24 137)
</code></pre>

<p><code>(imapping-values</code>&nbsp;<em>imap</em><code>) → list[*]</code></p>

<p>Returns the elements of <em>imap</em> as a list in ascending numerical
order of key.</p>

<p>Example:</p>

<pre class="example"><code>(imapping-values (imapping 0 "picard" 1 "riker" 2 "troi"))
 ⇒ ("picard" "riker" "troi")
</code></pre>

<p><code>(imapping-&gt;generator</code> <em>imapping</em><code>) → generator[pair(exact-integer, *)]</code></p>

<p>Returns a <a href="https://srfi.schemers.org/srfi-158/">SRFI 158</a> generator which
produces the associations of <em>imapping</em> as key/value pairs in increasing
order of key.</p>

<p>Example:</p>

<pre class="example"><code>(generator-&gt;list (imapping-&gt;generator (imapping 3 "yar" 2 "troi")))
 ⇒ ((2 . "troi") (3 . "yar"))
</code></pre>

<p><code>(imapping-&gt;decreasing-generator</code> <em>imapping</em><code>) → generator[pair(exact-integer, *)]</code></p>

<p>This is the same as <code>imapping-&gt;generator</code>, except that the associations
of <em>imapping</em> are produced in decreasing order of key.</p>

<p>Example:</p>

<pre class="example"><code>(generator-&gt;list (imapping-&gt;decreasing-generator (imapping 3 "yar" 2 "troi")))
 ⇒ ((3 . "yar") (2 . "troi"))
</code></pre>

<h3 id="comparison">Comparison</h3>

<p>Each of the following predicates takes a
<a href="https://srfi.schemers.org/srfi-128/">SRFI 128</a> comparator
argument which is used to compare the values of the associations of
two imappings.  (Keys are always compared with <code>=</code>.)</p>

<p>Note that none of these five predicates produces a total order on
imappings.  In particular, <code>imapping=?</code>, <code>imapping&lt;?</code>,
and <code>imapping&gt;?</code> do not obey the trichotomy law.</p>

<p><code>(imapping=?</code>&nbsp;<em>comp imap</em>₁ <em>imap</em>₂ <em>imap</em>₃ <code>…) → boolean</code></p>

<p>Returns <code>#t</code> if and only if all of the <em>imaps</em> contain equal
associations.  Two associations are equal exactly when their keys are
equal (in the sense of <code>=</code>) and their values are equal in the sense
of the equality predicate of <em>comp</em>.</p>

<p>Examples:</p>

<pre class="example"><code>(imapping=? (make-default-comparator)
            (imapping 1 'a 2 'b)
            (imapping 2 'b 1 'a))
 ⇒ #t

(imapping=? (make-default-comparator)
            (imapping 1 'a 2 'b 3 'c)
            (imapping 2 'b 1 'a))
 ⇒ #f
</code></pre>

<p><code>(imapping&lt;?</code>&nbsp;<em>comp</em> <em>imap</em>₁ <em>imap</em>₂ <em>imap</em>₃ <code>…) → boolean</code><br>
<code>(imapping&lt;=?</code>&nbsp;<em>comp</em> <em>imap</em>₁ <em>imap</em>₂ <em>imap</em>₃ <code>…) → boolean</code><br>
<code>(imapping&gt;?</code>&nbsp;<em>comp</em> <em>imap</em>₁ <em>imap</em>₂ <em>imap</em>₃ <code>…) → boolean</code><br>
<code>(imapping&gt;=?</code>&nbsp;<em>comp</em> <em>imap</em>₁ <em>imap</em>₂ <em>imap</em>₃ <code>…) → boolean</code></p>

<p>Returns <code>#t</code> if and only if each <em>imap</em> other than the last is a proper
subset/subset/proper superset/superset of the following <em>imap</em>.  Values are
compared using the equality predicate of <em>comp</em>.</p>

<p>Examples:</p>

<pre class="example"><code>(imapping&lt;? (make-default-comparator)
            (imapping 1 'a 2 'b)
            (imapping 2 'b 1 'a 3 'c))
 ⇒ #t

(imapping&gt;? (make-default-comparator)
            (imapping 2 'b 1 "worf" 3 'c)
            (imapping 1 'a 2 'b))
 ⇒ #f

(imapping&gt;=? (make-default-comparator)
             (imapping 2 'b 1 'a 3 'c)
             (imapping 1 'a 2 'b)
             (imapping 2 'b 1 'a)
             (imapping 1 'a))
 ⇒ #t
</code></pre>

<h3 id="settheory">Set theory operations</h3>

<p><code>(imapping-union</code>&nbsp;<em>imap</em>₁ <em>imap</em>₂ <em>imap</em>₃ …<code>) → imapping</code><br>
<code>(imapping-intersection</code>&nbsp;<em>imap</em>₁ <em>imap</em>₂ <em>imap</em>₃ …<code>) → imapping</code><br>
<code>(imapping-difference</code>&nbsp;<em>imap</em>₁ <em>imap</em>₂ <em>imap</em>₃ …<code>) → imapping</code><br>
<code>(imapping-xor</code>&nbsp;<em>imap</em>₁ <em>imap</em>₂<code>) → imapping</code></p>

<p>Return a newly allocated imapping whose set of associations is the
union, intersection, asymmetric difference, or symmetric difference of
the sets of associations of the <em>imaps</em>.  Asymmetric difference is
extended to more than two imappings by taking the difference between
the first imapping and the union of the others.  Symmetric difference
is not extended beyond two imappings.  When comparing associations,
only the keys are compared.  In case of duplicate keys, associations
in the result imapping are drawn from the first imapping in which they
appear.</p>

<p>Examples:</p>

<pre class="example"><code>(imapping-&gt;alist (imapping-union (imapping 0 'a 2 'c)
                                 (imapping 1 'b 3 'd)))
 ⇒ ((0 . a) (1 . b) (2 . c) (3 . d))

(imapping-&gt;alist
 (imapping-intersection (imapping 0 'a 2 'c)
                        (imapping 1 'b 2 'c 3 'd)
                        (imapping 2 'c 4 'e)))
 ⇒ ((2 . c))

(imapping-&gt;alist (imapping-difference (imapping 0 'a 1 'b 2 'c)
                                      (imapping 2 "worf")
                                      (imapping 1 "data")))
 ⇒ ((0 . a))
</code></pre>

<p><code>(imapping-union!</code>&nbsp;<em>imap</em>₁ <em>imap</em>₂ <em>imap</em>₃ …<code>) → imapping</code><br>
<code>(imapping-intersection!</code>&nbsp;<em>imap</em>₁ <em>imap</em>₂ <em>imap</em>₃ …<code>) → imapping</code><br>
<code>(imapping-difference!</code>&nbsp;<em>imap</em>₁ <em>imap</em>₂ <em>imap</em>₃ …<code>) → imapping</code><br>
<code>(imapping-xor!</code>&nbsp;<em>imap</em>₁ <em>imap</em>₂<code>) → imapping</code></p>

<p>These are linear-update variants of
<code>imapping-union</code>, etc..  They may
mutate <strong>any</strong> of the <em>imap</em> parameters to
produce their results.</p>

<p><code>(imapping-union/combinator</code>&nbsp;<em>proc imap</em>₁ <em>imap</em>₂ <em>imap</em>₃ …<code>) → imapping</code><br>
<code>(imapping-intersection/combinator</code>&nbsp;<em>proc imap</em>₁ <em>imap</em>₂ <em>imap</em>₃ …<code>) → imapping</code></p>

<p><em>proc</em> is a procedure of type <code>* * → *</code>.</p>

<p>Return a new imapping whose set of keys is the union/intersection of
the sets of keys of the <em>imaps</em>.  The values associated with duplicate
keys are combined left-associatively with <em>proc</em>; that is, if an integer <em>k</em> is associated
with values <em>v</em>₁, <em>v</em>₂, …, <em>v</em>ₙ in <em>imap</em>₁, <em>imap</em>₂, …, <em>imap</em>ₙ,
respectively, then the resulting imapping will contain the association
(<em>k</em>, (<em>proc</em> … (<em>proc v</em>₁ <em>v</em>₂) … <em>v</em>ₙ)).</p>

<p>Examples:</p>

<pre class="example"><code>;; Right-biased union.
(imapping-&gt;alist
 (imapping-union/combinator (lambda (_l r) r)
                            (imapping 1 'b 2 'c)
                            (imapping 2 "data" 3 "picard")))

 ⇒ ((1 . b) (2 . "data") (3 . "picard"))

(imapping-&gt;alist
 (imapping-intersection/combinator
  (lambda (l r) (string-append l " " r))
  (imapping 1 "q" 3 "jean-luc" 5 "miles" 7 "quark")
  (imapping 3 "picard" 5 "o'brien")))

 ⇒ ((3 . "jean-luc picard") (5 . "miles o'brien"))
</code></pre>

<p><code>(imapping-union/combinator!</code>&nbsp;<em>proc imap</em>₁ <em>imap</em>₂ <em>imap</em>₃ …<code>) → imapping</code><br>
<code>(imapping-intersection/combinator!</code>&nbsp;<em>proc imap</em>₁ <em>imap</em>₂ <em>imap</em>₃ …<code>) → imapping</code></p>

<p>These are linear-update variants of <code>imapping-union/combinator</code>
and <code>imapping-intersection/combinator</code>.  They may
mutate <strong>any</strong> of the <em>imap</em> parameters to
produce their results.</p>

<h3 id="submappings">Submappings</h3>

<p><code>(imapping-open-interval</code>&nbsp;<em>imap low high</em><code>) → imapping</code><br>
<code>(imapping-closed-interval</code>&nbsp;<em>imap low high</em><code>) → imapping</code><br>
<code>(imapping-open-closed-interval</code>&nbsp;<em>imap low high</em><code>) → imapping</code><br>
<code>(imapping-closed-open-interval</code>&nbsp;<em>imap low high</em><code>) → imapping</code></p>

<p><em>low</em> and <em>high</em> are both exact integers.</p>

<p>Procedures that return a subset of <em>imap</em> containing the associations
whose keys are contained in the interval from <em>low</em> to <em>high</em>.  The
interval is open/closed/open below and closed above/open
above and closed below.</p>

<p>Examples:</p>

<pre class="example"><code>(imapping-&gt;alist
 (imapping-open-interval (imapping 0 'a 1 'b 2 'c 3 'd) 1 3))
 ⇒ ((2 . c))

(imapping-&gt;alist
 (imapping-closed-interval (imapping 0 'a 1 'b 2 'c 3 'd) 1 3))
 ⇒ ((1 . b) (2 . c) (3 . d))

(imapping-&gt;alist
 (imapping-closed-open-interval (imapping 0 'a 1 'b 2 'c 3 'd) 1 3))
 ⇒ ((1 . b) (2 . c))
</code></pre>

<p><code>(imapping-open-interval!</code>&nbsp;<em>imap low high</em><code>) → imapping</code><br>
<code>(imapping-closed-interval!</code>&nbsp;<em>imap low high</em><code>) → imapping</code><br>
<code>(imapping-open-closed-interval!</code>&nbsp;<em>imap low high</em><code>) → imapping</code><br>
<code>(imapping-closed-open-interval!</code>&nbsp;<em>imap low high</em><code>) → imapping</code></p>

<p>These are linear-update variants of
<code>imapping-open-interval</code>, etc..  They may
mutate and return the <em>imap</em> parameter instead of allocating
a new imapping.</p>

<p><code>(isubmapping=</code>&nbsp;<em>imap k</em><code>) → imapping</code><br>
<code>(isubmapping&lt;</code>&nbsp;<em>imap k</em><code>) → imapping</code><br>
<code>(isubmapping&lt;=</code>&nbsp;<em>imap k</em><code>) → imapping</code><br>
<code>(isubmapping&gt;</code>&nbsp;<em>imap k</em><code>) → imapping</code><br>
<code>(isubmapping&gt;=</code>&nbsp;<em>imap k</em><code>) → imapping</code></p>

<p>Procedures that return an imapping containing the associations of
<em>imap</em> whose keys are equal to/less than/less than or equal
to/greater than/greater than or equal to <em>k</em>.  Note that the result of
<code>isubmapping=</code> contains at most one element.</p>

<p>Examples:</p>

<pre class="example"><code>(imapping-&gt;alist
 (isubmapping= (imapping 0 'a 1 'b 2 'c 3 'd) 2))
 ⇒ ((2 . c))

(imapping-&gt;alist
 (isubmapping&lt; (imapping 0 'a 1 'b 2 'c 3 'd) 2))
 ⇒ ((0 . a) (1 . b))

(imapping-&gt;alist
 (isubmapping&gt;= (imapping 0 'a 1 'b 2 'c 3 'd) 2))
 ⇒ ((2 . c) (3 . d))
</code></pre>

<p><code>(isubmapping=!</code>&nbsp;<em>imap k</em><code>) → imapping</code><br>
<code>(isubmapping&lt;!</code>&nbsp;<em>imap k</em><code>) → imapping</code><br>
<code>(isubmapping&lt;=!</code>&nbsp;<em>imap k</em><code>) → imapping</code><br>
<code>(isubmapping&gt;!</code>&nbsp;<em>imap k</em><code>) → imapping</code><br>
<code>(isubmapping&gt;=!</code>&nbsp;<em>imap k</em><code>) → imapping</code></p>

<p>These are linear-update variants of
<code>isubmapping=</code>, etc..  They may
mutate and return the <em>imap</em> parameter instead of allocating
a new imapping.</p>

<p><code>(imapping-split</code> <em>imap k</em><code>) → [imapping, imapping]</code></p>

<p>Returns two new imappings.  The first contains all of the associations
of <em>imap</em> whose keys are less than or equal to <em>k</em>, and the second
contains the remaining associations.  This is equivalent to
<code>(values (isubmapping&lt;=</code>&nbsp;<em>imap k</em><code>)
(isubmapping&gt;</code>&nbsp;<em>imap k</em><code>))</code>, but may be
implemented more efficiently.</p>

<p>If <em>imap</em> is empty, then both of the imappings returned by
<code>imapping-split</code> are empty.</p>

<p>Example:</p>

<pre class="example"><code>(let-values ((imaps (imapping-split (imapping 0 'a 1 'b 2 'c 3 'd) 2)))
  (map imapping-&gt;alist imaps))

 ⇒ (((0 . a) (1 . b) (2 . c))
    ((3 . d)))
</code></pre>

<h2 id="implementation">Implementation</h2>

<p>The sample implementation is found in the repository for this SRFI.
The imapping implementation is based on big-endian radix (Patricia) trees
as described by Chris Okasaki and Andrew Gill in &ldquo;Fast
Mergeable Integer Maps&rdquo; (see <a href="#references">References</a>).
These trees provide fast insert, lookup, and set-theoretical operations.
Keys are currently restricted to fixnums.</p>

<p>The implementation should be portable without changes to any R7RS
Scheme that provides SRFIs 1, 128, 143, 145, 158, 189, and 217.  The provided
tests can be run with SRFIs 64 or 78; additional shims for the test
libraries preferred by <a href="http://synthcode.com/scheme/chibi/lib/chibi/test.html">chibi-scheme</a>
and <a href="https://wiki.call-cc.org/eggref/5/test">CHICKEN</a> are also
included.</p>

<h2>Acknowledgements</h2>

<p>Thanks to Marc-Nieper Wißkirchen and Arthur A. Gleckler, the
authors of SRFI 146, as well as to Daan Leijen and Andriy Palamarchuk,
who created the Haskell IntMap library.  These libraries provided
critical inspiration and implementation clues in the creation of this
SRFI.</p>

<p>Thanks to the SRFI editor and to the contributors to the SRFI
mailing list, as well as to those who provided feedback on this SRFI
via the <code>#scheme</code> IRC channel.</p>

<p>This SRFI contains ideas and language drawn from dozens of other
SRFIs, in particular specifications by Olin Shivers, John Cowan, and
Taylor Campbell.  The R7RS and earlier standards also provided
constant design and literary guidance.  Thus, little of what appears
in this SRFI is &ldquo;original&rdquo;.  Thanks to all of the Schemers who have
contributed their knowledge and time to the SRFI process and to the
R<sup><em>n</em></sup>RS standards.</p>

<p>Of course, none of this should be understood to imply that any of
the individuals mentioned above endorse this SRFI.</p>

<h2 id="references">References</h2>

<p>Alex Shinn, John Cowan, &amp; Arthur A. Gleckler, eds., <em>Revised⁷ Report
on the Algorithmic Language Scheme</em> (R7RS) (2013).  Available
<a href="https://small.r7rs.org/">on the Web</a>.</p>

<p>Michael Sperber, R. Kent Dybvig, Matthew Flatt, &amp; Anton van
Straaten, eds., <em>The Revised⁶ Report on the Algorithmic Language
Scheme</em> (R6RS).  Cambridge University Press, 2010.  Available
<a href="http://www.r6rs.org/final/html/r6rs/r6rs.html">on the Web</a>.</p>

<p>Chris Okasaki &amp; Andrew Gill, &ldquo;Fast Mergeable Integer Maps&rdquo;,
1998 <em>Workshop on ML</em>, p. 77-86.</p>

<p>S. Bradner, &ldquo;Key words for use in RFCs to Indicate Requirement Levels&rdquo;.
1997. http://www.ietf.org/rfc/rfc2119.txt</p>

<h2>Copyright</h2>

<p>&copy; 2021 Wolfgang Corcoran-Mathe.  All rights reserved.</p>

<p>Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
&ldquo;Software&rdquo;), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:</p>

<p>The above copyright notice and this permission notice (including the
next paragraph) shall be included in all copies or substantial portions
of the Software.</p>

<p>THE SOFTWARE IS PROVIDED &ldquo;AS IS&rdquo;, WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>
<hr>
<address>Editor: <a href="mailto:srfi-editors+at+srfi+dot+schemers+dot+org">Arthur A. Gleckler</a></address>
</body>
</html>
